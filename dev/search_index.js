var documenterSearchIndex = {"docs":
[{"location":"highlevels/function_approximation/#Function-Approximation","page":"Function Approximation","title":"Function Approximation","text":"","category":"section"},{"location":"highlevels/function_approximation/","page":"Function Approximation","title":"Function Approximation","text":"While SciML is not an ecosystem for machine learning, SciML has many libraries for doing machine learning with its equation solver libraries and machine learning libraries which are integrated into the equation solvers.","category":"page"},{"location":"highlevels/function_approximation/#Surrogates.jl:-Easy-Generation-of-Differentiable-Surrogate-Models","page":"Function Approximation","title":"Surrogates.jl: Easy Generation of Differentiable Surrogate Models","text":"","category":"section"},{"location":"highlevels/function_approximation/","page":"Function Approximation","title":"Function Approximation","text":"Surrogates.jl is a library for generating surrogate approximations to computationally expensive simulations. It has the following high-dimensional function approximators:","category":"page"},{"location":"highlevels/function_approximation/","page":"Function Approximation","title":"Function Approximation","text":"Kriging\nKriging using Stheno\nRadial Basis\nWendland\nLinear\nSecond Order Polynomial\nSupport Vector Machines (Wait for LIBSVM resolution)\nNeural Networks\nRandom Forests\nLobachevsky splines\nInverse-distance\nPolynomial expansions\nVariable fidelity\nMixture of experts (Waiting GaussianMixtures package to work on v1.5)\nEarth\nGradient Enhanced Kriging","category":"page"},{"location":"highlevels/function_approximation/#ReservoirComputing.jl:-Fast-and-Flexible-Reservoir-Computing-Methods","page":"Function Approximation","title":"ReservoirComputing.jl: Fast and Flexible Reservoir Computing Methods","text":"","category":"section"},{"location":"highlevels/function_approximation/","page":"Function Approximation","title":"Function Approximation","text":"ReservoirComputing.jl is a library for doing machine learning using reservoir computing techniques, such as with methods like Echo State Networks (ESNs). Its reservoir computing methods make it stabilized for usage with difficult equations like stiff dynamics, chaotic equations, and more.","category":"page"},{"location":"highlevels/function_approximation/#Third-Party-Libraries-to-Note","page":"Function Approximation","title":"Third Party Libraries to Note","text":"","category":"section"},{"location":"highlevels/function_approximation/#Flux.jl:-the-ML-library-that-doesn't-make-you-tensor","page":"Function Approximation","title":"Flux.jl: the ML library that doesn't make you tensor","text":"","category":"section"},{"location":"highlevels/function_approximation/","page":"Function Approximation","title":"Function Approximation","text":"Flux.jl is the most popular machine learning library in the Julia programming language. SciML's libraries are heavily tested with it and its automatic differentiation engine Zygote.jl for composability and compatibility.","category":"page"},{"location":"highlevels/function_approximation/#Lux.jl:-Explicitly-Parameterized-Neural-Networks-in-Julia","page":"Function Approximation","title":"Lux.jl: Explicitly Parameterized Neural Networks in Julia","text":"","category":"section"},{"location":"highlevels/function_approximation/","page":"Function Approximation","title":"Function Approximation","text":"Lux.jl is a library for fully explicitly parameterized neural networks. Thus while alternative interfaces are required to use Flux with many equation solvers (i.e. Flux.destructure), Lux.jl's explicit design marries very easily with the SciML equation solver libraries. For this reason, SciML's library are also heavily tested with Lux to ensure compatibility with neural network definitions from here.","category":"page"},{"location":"highlevels/function_approximation/#SimpleChains.jl:-Fast-Small-Scale-Machine-Learning","page":"Function Approximation","title":"SimpleChains.jl: Fast Small-Scale Machine Learning","text":"","category":"section"},{"location":"highlevels/function_approximation/","page":"Function Approximation","title":"Function Approximation","text":"SimpleChains.jl is a library specialized for small-scale machine learning. It uses non-allocating mutating forms to be highly efficient for the cases where matrix multiplication kernels are not able to overcome the common overheads of machine learning libraries. Thus for SciML cases with small neural networks (<100 node layers) and non-batched usage (many/most use cases), SimpleChains.jl can be the fastest choice for the neural network definitions.","category":"page"},{"location":"highlevels/function_approximation/#NNLib.jl:-Neural-Network-Primitives-with-Multiple-Backends","page":"Function Approximation","title":"NNLib.jl: Neural Network Primitives with Multiple Backends","text":"","category":"section"},{"location":"highlevels/function_approximation/","page":"Function Approximation","title":"Function Approximation","text":"NNLib.jl is the core library which defines the handling of common functions, like conv and how they map to device accelerators such as the NVIDIA cudnn. This library can thus be used to directly grab many of the core functions used in machine learning, such as common activation functions and gather/scatter operations, without depending on the given style of any machine learning library.","category":"page"},{"location":"highlevels/function_approximation/#GeometricFlux.jl:-Geometric-Deep-Learning-and-Graph-Neural-Networks","page":"Function Approximation","title":"GeometricFlux.jl: Geometric Deep Learning and Graph Neural Networks","text":"","category":"section"},{"location":"highlevels/function_approximation/","page":"Function Approximation","title":"Function Approximation","text":"GeometricFlux.jl is a library for graph neural networks and geometric deep learning. It is the one that is used and tested by the SciML developers for mixing with equation solver applications.","category":"page"},{"location":"highlevels/function_approximation/#AbstractGPs.jl:-Fast-and-Flexible-Gaussian-Processes","page":"Function Approximation","title":"AbstractGPs.jl: Fast and Flexible Gaussian Processes","text":"","category":"section"},{"location":"highlevels/function_approximation/","page":"Function Approximation","title":"Function Approximation","text":"AbstractGPs.jl is the fast and flexible Gaussian Process library that is used by the SciML packages and recommended for downstream usage.","category":"page"},{"location":"highlevels/function_approximation/#MLDatasets.jl:-Common-Machine-Learning-Datasets","page":"Function Approximation","title":"MLDatasets.jl: Common Machine Learning Datasets","text":"","category":"section"},{"location":"highlevels/function_approximation/","page":"Function Approximation","title":"Function Approximation","text":"MLDatasets.jl  is a common interface for accessing common machine learning datasets. For example, if you want to run a test on MNIST data, MLDatasets is the quickest way to obtain it.","category":"page"},{"location":"highlevels/function_approximation/#MLUtils.jl:-Utility-Functions-for-Machine-Learning-Pipelines","page":"Function Approximation","title":"MLUtils.jl: Utility Functions for Machine Learning Pipelines","text":"","category":"section"},{"location":"highlevels/function_approximation/","page":"Function Approximation","title":"Function Approximation","text":"MLUtils.jl is a library of utility functions for making writing common machine learning pipelines easier. This includes functionality for:","category":"page"},{"location":"highlevels/function_approximation/","page":"Function Approximation","title":"Function Approximation","text":"An extensible dataset interface  (numobs and getobs).\nData iteration and dataloaders (eachobs and DataLoader).\nLazy data views (obsview).\nResampling procedures (undersample and oversample).\nTrain/test splits (splitobs)\nData partitioning and aggregation tools (batch, unbatch, chunk, group_counts, group_indices).\nFolds for cross-validation (kfolds, leavepout).\nDatasets lazy tranformations (mapobs, filterobs, groupobs, joinobs, shuffleobs).\nToy datasets for demonstration purpose.\nOther data handling utilities (flatten, normalise, unsqueeze, stack, unstack).","category":"page"},{"location":"highlevels/interfaces/#The-SciML-Interface-Libraries","page":"The SciML Interface Libraries","title":"The SciML Interface Libraries","text":"","category":"section"},{"location":"highlevels/interfaces/#SciMLBase.jl:-The-SciML-Common-Interface","page":"The SciML Interface Libraries","title":"SciMLBase.jl: The SciML Common Interface","text":"","category":"section"},{"location":"highlevels/interfaces/","page":"The SciML Interface Libraries","title":"The SciML Interface Libraries","text":"SciMLBase.jl defines the core interfaces of the SciML libraries, such as the definitions of abstract types like SciMLProblem, along with their instantiations like ODEProblem. While SciMLBase.jl is insufficient to solve any equations, it holds all of the equation definitions, and thus downstream libraries which wish to allow for using SciML solvers without depending on any solvers can directly depend on SciMLBase.jl.","category":"page"},{"location":"highlevels/interfaces/#SciMLOperators.jl:-The-AbstractSciMLOperator-Interface","page":"The SciML Interface Libraries","title":"SciMLOperators.jl: The AbstractSciMLOperator Interface","text":"","category":"section"},{"location":"highlevels/interfaces/","page":"The SciML Interface Libraries","title":"The SciML Interface Libraries","text":"SciMLOperators.jl defines the interface for how matrix-free linear and affine operators are defined and used throughout the SciML ecosystem.","category":"page"},{"location":"highlevels/interfaces/#DiffEqNoiseProcess.jl:-The-SciML-Common-Noise-Interface","page":"The SciML Interface Libraries","title":"DiffEqNoiseProcess.jl: The SciML Common Noise Interface","text":"","category":"section"},{"location":"highlevels/interfaces/","page":"The SciML Interface Libraries","title":"The SciML Interface Libraries","text":"DiffEqNoiseProcess.jl defines the common interface for stochastic noise processes used by the equation solvers of the SciML ecosystem.","category":"page"},{"location":"highlevels/interfaces/#CommonSolve.jl:-The-Common-Definition-of-Solve","page":"The SciML Interface Libraries","title":"CommonSolve.jl: The Common Definition of Solve","text":"","category":"section"},{"location":"highlevels/interfaces/","page":"The SciML Interface Libraries","title":"The SciML Interface Libraries","text":"CommonSolve.jl is the library that defines the solve, solve!, and init interfaces which are used throughout all of the SciML equation solvers. It's defined as an extremely lightweight library so that other ecosystems can build off of the same solve definition without clashing with SciML when both export.","category":"page"},{"location":"highlevels/interfaces/#Static.jl:-A-Shared-Interface-for-Static-Compile-Time-Computation","page":"The SciML Interface Libraries","title":"Static.jl: A Shared Interface for Static Compile-Time Computation","text":"","category":"section"},{"location":"highlevels/interfaces/","page":"The SciML Interface Libraries","title":"The SciML Interface Libraries","text":"Static.jl is a set of statically parameterized types for performing operations in a statically-defined (compiler-optimized) way with respect to values.","category":"page"},{"location":"highlevels/interfaces/#DiffEqBase.jl:-A-Library-of-Shared-Components-for-Differential-Equation-Solvers","page":"The SciML Interface Libraries","title":"DiffEqBase.jl: A Library of Shared Components for Differential Equation Solvers","text":"","category":"section"},{"location":"highlevels/interfaces/","page":"The SciML Interface Libraries","title":"The SciML Interface Libraries","text":"DiffEqBase.jl is the core shared component of the DifferentialEquations.jl ecosystem. It's not intended for non-developer users to interface directly with, instead it's used for the common functionality for uniformity of implementation between the solver libraries.","category":"page"},{"location":"highlevels/interfaces/#Third-Party-Libraries-to-Note","page":"The SciML Interface Libraries","title":"Third Party Libraries to Note","text":"","category":"section"},{"location":"highlevels/interfaces/#ArrayInterface.jl:-Extensions-to-the-Julia-AbstractArray-Interface","page":"The SciML Interface Libraries","title":"ArrayInterface.jl: Extensions to the Julia AbstractArray Interface","text":"","category":"section"},{"location":"highlevels/interfaces/","page":"The SciML Interface Libraries","title":"The SciML Interface Libraries","text":"ArrayInterface.jl are traits and functions which extend the Julia Base AbstractArray interface, giving a much larger set of queries to allow for writing high-performance generic code over all array types. For example, functions include can_change_size to know if an AbstractArray type is compatible with resize!, fast_scalar_indexing to know whether direct scalar indexing A[i] is optimized, and functions like findstructralnz to get the structural non-zeros of arbitrary sparse and structured matrices.","category":"page"},{"location":"highlevels/interfaces/#Adapt.jl:-Conversion-to-Allow-Chip-Generic-Programs","page":"The SciML Interface Libraries","title":"Adapt.jl: Conversion to Allow Chip-Generic Programs","text":"","category":"section"},{"location":"highlevels/interfaces/","page":"The SciML Interface Libraries","title":"The SciML Interface Libraries","text":"Adapt.jl makes it possible to write code that is generic to the compute devices, i.e. code that works on both CPUs and GPUs. It defines the adapt function which acts like convert(T, x), but without the restriction of returning a T. This allows you to \"convert\" wrapper types like Adjoint to be GPU compatible (for example) without throwing away the wrapper.","category":"page"},{"location":"highlevels/interfaces/","page":"The SciML Interface Libraries","title":"The SciML Interface Libraries","text":"Example usage:","category":"page"},{"location":"highlevels/interfaces/","page":"The SciML Interface Libraries","title":"The SciML Interface Libraries","text":"adapt(CuArray, ::Adjoint{Array})::Adjoint{CuArray}","category":"page"},{"location":"highlevels/interfaces/#AbstractFFTs.jl:-High-Level-Shared-Interface-for-Fast-Fourier-Transformation-Libraries","page":"The SciML Interface Libraries","title":"AbstractFFTs.jl: High Level Shared Interface for Fast Fourier Transformation Libraries","text":"","category":"section"},{"location":"highlevels/interfaces/","page":"The SciML Interface Libraries","title":"The SciML Interface Libraries","text":"AbstractFFTs.jl defines the common interface for Fast Fourier Transformations (FFTs) in Julia. Similar to SciMLBase.jl, AbstractFFTs.jl is not a solver library but instead a shared API which is extended by solver libraries such as FFTW.jl. Code written using AbstractFFTs.jl can be made compatible with FFT libraries without having an explicit dependency on a solver.","category":"page"},{"location":"highlevels/interfaces/#GPUArrays.jl:-Common-Interface-for-GPU-Based-Array-Types","page":"The SciML Interface Libraries","title":"GPUArrays.jl: Common Interface for GPU-Based Array Types","text":"","category":"section"},{"location":"highlevels/interfaces/","page":"The SciML Interface Libraries","title":"The SciML Interface Libraries","text":"GPUArrays.jl defines the shared higher-level operations for GPU-based array types like CUDA.jl's CuArray and AMDGPU.jl's ROCmArray. Packages in SciML use the designation x isa AbstractGPUArray in order to find out if a user's operation is on the GPU and specialize computations.","category":"page"},{"location":"highlevels/interfaces/#RecipesBase.jl:-Standard-Plotting-Recipe-Interface","page":"The SciML Interface Libraries","title":"RecipesBase.jl: Standard Plotting Recipe Interface","text":"","category":"section"},{"location":"highlevels/interfaces/","page":"The SciML Interface Libraries","title":"The SciML Interface Libraries","text":"RecipesBase.jl defines the common interface for plotting recipes, composable transformations of Julia data types into simpler data types for visualization with libraries such as Plots.jl and Makie.jl. SciML libraries attempt to always include plot recipes wherever possible for ease of visualization.","category":"page"},{"location":"highlevels/interfaces/#Tables.jl:-Common-Interface-for-Tabular-Data-Types","page":"The SciML Interface Libraries","title":"Tables.jl: Common Interface for Tabular Data Types","text":"","category":"section"},{"location":"highlevels/interfaces/","page":"The SciML Interface Libraries","title":"The SciML Interface Libraries","text":"Tables.jl is a common interface for defining tabular data structures, such as DataFrames.jl. SciML's libraries extend the Tables.jl interface to allow for automated conversions into data frame libraries without explicit dependence on any singular implementation.","category":"page"},{"location":"highlevels/parameter_analysis/#Parameter-Analysis-Utilities","page":"Parameter Analysis Utilities","title":"Parameter Analysis Utilities","text":"","category":"section"},{"location":"highlevels/parameter_analysis/#GlobalSensitivity.jl:-Global-Sensitivity-Analysis","page":"Parameter Analysis Utilities","title":"GlobalSensitivity.jl: Global Sensitivity Analysis","text":"","category":"section"},{"location":"highlevels/parameter_analysis/","page":"Parameter Analysis Utilities","title":"Parameter Analysis Utilities","text":"Derivatives calculate the local sensitivity of a model, i.e. the change in the simulation's outcome if one was to change the parameter with respect to some chosen part of the parameter space. But how does a simulation's output change \"in general\" with respect to a given parameter? That is what global sensitivity analysis (GSA) computes, and thus GlobalSensitivity.jl is the way to answer that question. GlobalSensitivity.jl includes a wide array of methods, including:","category":"page"},{"location":"highlevels/parameter_analysis/","page":"Parameter Analysis Utilities","title":"Parameter Analysis Utilities","text":"Morris's method\nSobol's method\nRegression methods (PCC, SRC, Pearson)\neFAST\nDelta Moment-Independent method\nDerivative-based Global Sensitivity Measures (DGSM)\nEASI\nFractional Factorial method\nRandom Balance Design FAST method","category":"page"},{"location":"highlevels/parameter_analysis/#StructuralIdentifiability.jl:-Identifiability-Analysis-Made-Simple","page":"Parameter Analysis Utilities","title":"StructuralIdentifiability.jl: Identifiability Analysis Made Simple","text":"","category":"section"},{"location":"highlevels/parameter_analysis/","page":"Parameter Analysis Utilities","title":"Parameter Analysis Utilities","text":"Performing parameter estimation from a data set means attempting to recover parameters like reaction rates by fitting some model to the data. But how do you know whether you have enough data to even consider getting the \"correct\" parameters back? StructuralIdentifiability.jl allows for running a structural identifiability analysis on a given model to determine whether it's theoretically possible to recover the correct parameters. It can state whether a given type of output data can be used to globally recover the parameters (i.e. only a unique parameter set for the model produces a given output), whether the parameters are only locally identifiable (i.e. there are finitely many parameter sets which could generate the seen data), or whether it's unidentifiable (there are infinitely many parameters which generate the same output data).","category":"page"},{"location":"highlevels/parameter_analysis/","page":"Parameter Analysis Utilities","title":"Parameter Analysis Utilities","text":"For more information on what StructuralIdentifiability.jl is all about, see the SciMLCon 2022 tutorial video.","category":"page"},{"location":"highlevels/parameter_analysis/#MinimallyDisruptiveCurves.jl","page":"Parameter Analysis Utilities","title":"MinimallyDisruptiveCurves.jl","text":"","category":"section"},{"location":"highlevels/parameter_analysis/","page":"Parameter Analysis Utilities","title":"Parameter Analysis Utilities","text":"MinimallyDisruptiveCurves.jl is a library for finding relationships between parameters of models, finding the curves on which the solution is constant.","category":"page"},{"location":"highlevels/parameter_analysis/#Third-Party-Libraries-to-Note","page":"Parameter Analysis Utilities","title":"Third Party Libraries to Note","text":"","category":"section"},{"location":"highlevels/parameter_analysis/#SIAN.jl:-Structural-Identifiability-Analyzer","page":"Parameter Analysis Utilities","title":"SIAN.jl: Structural Identifiability Analyzer","text":"","category":"section"},{"location":"highlevels/parameter_analysis/","page":"Parameter Analysis Utilities","title":"Parameter Analysis Utilities","text":"SIAN.jl is a structural identifiability analysis package which uses an entirely different algorithm from StructuralIdentifiability.jl. For information on the differences between the two approaches, see the Structural Identifiability Tools in Julia tutoral.","category":"page"},{"location":"highlevels/parameter_analysis/#DynamicalSystems.jl:-A-Suite-of-Dynamical-Systems-Analysis","page":"Parameter Analysis Utilities","title":"DynamicalSystems.jl: A Suite of Dynamical Systems Analysis","text":"","category":"section"},{"location":"highlevels/parameter_analysis/","page":"Parameter Analysis Utilities","title":"Parameter Analysis Utilities","text":"DynamicalSystems.jl is an entire ecosystem of dynamical systems analysis methods, for computing measures of chaos (dimension estimation, Lyapunov coefficients), generating delay embeddings, and much more. It uses the SciML tools for its internal equation solving and thus shares much of its API, adding a layer of new tools for extended analyses.","category":"page"},{"location":"highlevels/parameter_analysis/","page":"Parameter Analysis Utilities","title":"Parameter Analysis Utilities","text":"For more information, watch the tutorial Introduction to DynamicalSystems.jl.","category":"page"},{"location":"highlevels/parameter_analysis/#BifurcationKit.jl","page":"Parameter Analysis Utilities","title":"BifurcationKit.jl","text":"","category":"section"},{"location":"highlevels/parameter_analysis/","page":"Parameter Analysis Utilities","title":"Parameter Analysis Utilities","text":"BifurcationKit.jl is a tool for performing bifurcation analysis. It uses and composes with many SciML equation solvers.","category":"page"},{"location":"highlevels/parameter_analysis/#ReachabilityAnalysis.jl","page":"Parameter Analysis Utilities","title":"ReachabilityAnalysis.jl","text":"","category":"section"},{"location":"highlevels/parameter_analysis/","page":"Parameter Analysis Utilities","title":"Parameter Analysis Utilities","text":"ReachabilityAnalysis.jl is a library for performing reachability analysis of dynamical systems, determining for a given uncertainty interval the full set of possible outcomes from a dynamical system.","category":"page"},{"location":"highlevels/parameter_analysis/#ControlSystems.jl","page":"Parameter Analysis Utilities","title":"ControlSystems.jl","text":"","category":"section"},{"location":"highlevels/parameter_analysis/","page":"Parameter Analysis Utilities","title":"Parameter Analysis Utilities","text":"ControlSystems.jl is a library for building and analyzing control systems.","category":"page"},{"location":"getting_started/getting_started/#getting_started","page":"Getting Started with Julia's SciML","title":"Getting Started with Julia's SciML","text":"","category":"section"},{"location":"getting_started/getting_started/#Quickly:-What-is-Julia's-SciML-Ecosystem?","page":"Getting Started with Julia's SciML","title":"Quickly: What is Julia's SciML Ecosystem?","text":"","category":"section"},{"location":"getting_started/getting_started/","page":"Getting Started with Julia's SciML","title":"Getting Started with Julia's SciML","text":"Julia's SciML is:","category":"page"},{"location":"getting_started/getting_started/","page":"Getting Started with Julia's SciML","title":"Getting Started with Julia's SciML","text":"SciPy or MATLAB's standard library but in Julia, but\nRuns orders of magnitude faster, even outperforms C and Fortran libraries, and\nIs fully compatible with machine learning and automatic differentiation,\nAll while having an easy to use high level interactive development environment.","category":"page"},{"location":"getting_started/getting_started/","page":"Getting Started with Julia's SciML","title":"Getting Started with Julia's SciML","text":"Interested?","category":"page"},{"location":"getting_started/getting_started/#Introductory-Tutorials","page":"Getting Started with Julia's SciML","title":"Introductory Tutorials","text":"","category":"section"},{"location":"getting_started/getting_started/","page":"Getting Started with Julia's SciML","title":"Getting Started with Julia's SciML","text":"How do I install SciML software?\nBuild and run your first simulation\nSolve your first optimization problem\nFit a simulation to a dataset\nFind the root of an equation (i.e. solve f(x)=0)\nNumerically approximate an integral","category":"page"},{"location":"getting_started/getting_started/#Coming-from...","page":"Getting Started with Julia's SciML","title":"Coming from...","text":"","category":"section"},{"location":"getting_started/getting_started/","page":"Getting Started with Julia's SciML","title":"Getting Started with Julia's SciML","text":"Are you familiar with other scientific computing tools? Take a look at the guided introductions below.","category":"page"},{"location":"getting_started/getting_started/","page":"Getting Started with Julia's SciML","title":"Getting Started with Julia's SciML","text":"Introduction to Julia's SciML for the Python User\nIntroduction to Julia's SciML for the MATLAB User\nIntroduction to Julia's SciML for the R User\nIntroduction to Julia's SciML for the C++/Fortran User","category":"page"},{"location":"highlevels/symbolic_learning/#Symbolic-Learning-and-Artificial-Intelligence","page":"Symbolic Learning and Artificial Intelligence","title":"Symbolic Learning and Artificial Intelligence","text":"","category":"section"},{"location":"highlevels/symbolic_learning/","page":"Symbolic Learning and Artificial Intelligence","title":"Symbolic Learning and Artificial Intelligence","text":"Symbolic learning, the classical artificial intelligence, is a set of methods for learning symbolic equations from data and numerical functions. SciML offers an array of symbolic learning utilities which connect with the other machine learning and equation solver functionalities to make it easy to embed prior knowledge and discover missing physics. For more information, see Universal Differential Equations for Scientific Machine Learning","category":"page"},{"location":"highlevels/symbolic_learning/#DataDrivenDiffEq.jl:-Data-Driven-Modeling-and-Automated-Discovery-of-Dynamical-Systems","page":"Symbolic Learning and Artificial Intelligence","title":"DataDrivenDiffEq.jl: Data-Driven Modeling and Automated Discovery of Dynamical Systems","text":"","category":"section"},{"location":"highlevels/symbolic_learning/","page":"Symbolic Learning and Artificial Intelligence","title":"Symbolic Learning and Artificial Intelligence","text":"DataDrivenDiffEq.jl is a general interface for data-driven modeling, containing a large array of techniques such as:","category":"page"},{"location":"highlevels/symbolic_learning/","page":"Symbolic Learning and Artificial Intelligence","title":"Symbolic Learning and Artificial Intelligence","text":"Koopman operator methods (Dynamic-Mode Decomposition (DMD) and variations)\nSparse Identification of Dynamical Systems (SINDy and variations like iSINDy)\nSparse regression methods (STSLQ, SR3, etc.)\nPDEFind\nWrappers for SymbolicRegression.jl\nAI Feynman\nOccamNet","category":"page"},{"location":"highlevels/symbolic_learning/#SymbolicNumericIntegration.jl:-Symbolic-Integration-via-Numerical-Methods","page":"Symbolic Learning and Artificial Intelligence","title":"SymbolicNumericIntegration.jl: Symbolic Integration via Numerical Methods","text":"","category":"section"},{"location":"highlevels/symbolic_learning/","page":"Symbolic Learning and Artificial Intelligence","title":"Symbolic Learning and Artificial Intelligence","text":"SymbolicNumericIntegration.jl is a package computing the solution to symbolic integration problem using numerical methods (numerical integration mixed with sparse regression).","category":"page"},{"location":"highlevels/symbolic_learning/#Third-Party-Libraries-to-Note","page":"Symbolic Learning and Artificial Intelligence","title":"Third-Party Libraries to Note","text":"","category":"section"},{"location":"highlevels/symbolic_learning/#SymbolicRegression.jl","page":"Symbolic Learning and Artificial Intelligence","title":"SymbolicRegression.jl","text":"","category":"section"},{"location":"highlevels/symbolic_learning/","page":"Symbolic Learning and Artificial Intelligence","title":"Symbolic Learning and Artificial Intelligence","text":"SymbolicRegression.jl is a symbolic regression library which uses genetic algorithms with parallelization to achieve fast and robust symbolic learning.","category":"page"},{"location":"highlevels/array_libraries/#Modeling-Array-Libraries","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"","category":"section"},{"location":"highlevels/array_libraries/#RecursiveArrayTools.jl:-Arrays-of-Arrays-and-Even-Deeper","page":"Modeling Array Libraries","title":"RecursiveArrayTools.jl: Arrays of Arrays and Even Deeper","text":"","category":"section"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"Sometimes when one is creating a model, basic array types are not enough for expressing a complex concept. RecursiveArrayTools.jl gives many types, such as VectorOfArray and ArrayPartition, which allow for easily building nested array models in a way that conforms to the standard AbstractArray interface. While standard Vector{Array{Float64,N}} types may not be compatible with many equation solver libraries, these wrapped forms like VectorOfArray{Vector{Array{Float64,N}}} are, making it easy to use these more exotic array constructions.","category":"page"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"Note that SciML's interfaces use RecursiveArrayTools.jl extensively, for example, with the timeseries solution types being AbstractVectorOfArray.","category":"page"},{"location":"highlevels/array_libraries/#LabelledArrays.jl:-Named-Variables-in-Arrays-without-Overhead","page":"Modeling Array Libraries","title":"LabelledArrays.jl: Named Variables in Arrays without Overhead","text":"","category":"section"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"Sometimes you want to use a full domain-specific language like ModelingToolkit. Other times, you wish arrays just had a slightly nicer syntax. Don't you wish you could write the Lorenz equations like:","category":"page"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"function lorenz_f(du,u,p,t)\n  du.x = p.σ*(u.y-u.x)\n  du.y = u.x*(p.ρ-u.z) - u.y\n  du.z = u.x*u.y - p.β*u.z\nend","category":"page"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"without losing any efficiency? LabelledArrays.jl provides the array types to do just that. All of the . accesses are resolved at compile-time so it's a zero-overhead interface.","category":"page"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"note: Note\nWe recommend using ComponentArrays.jl for any instance where nested accesses is required, or where the . accesses need to be views to subsets of the array.","category":"page"},{"location":"highlevels/array_libraries/#MultiScaleArrays.jl:-Multiscale-Modeling-to-Compose-with-Equation-Solvers","page":"Modeling Array Libraries","title":"MultiScaleArrays.jl: Multiscale Modeling to Compose with Equation Solvers","text":"","category":"section"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"(Image: )","category":"page"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"How do you encode such real-world structures in a manner that is compatible with the SciML equation solver libraries? MultiScaleArrays.jl is an answer. MultiScaleArrays.jl gives a highly flexible interface for defining multi-level types which generates a corresponding interface as an AbstractArray. MultiScaleArrays.jl's flexibility includes the ease of resizing, allowing for models where the number of equations grows and shrinks as agents (cells) in the model divide and die.","category":"page"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"note: Note\nWe recommend using ComponentArrays.jl instead in any instance where the resizing functionality is not used.","category":"page"},{"location":"highlevels/array_libraries/#Third-Party-Libraries-to-Note","page":"Modeling Array Libraries","title":"Third Party Libraries to Note","text":"","category":"section"},{"location":"highlevels/array_libraries/#ComponentArrays.jl:-Arrays-with-Arbitrarily-Nested-Named-Components","page":"Modeling Array Libraries","title":"ComponentArrays.jl: Arrays with Arbitrarily Nested Named Components","text":"","category":"section"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"What if you had a set of arrays of arrays with names, but you wanted to represent them on a single contiguous vector so that linear algebra was as fast as possible, while retaining . named accesses with zero-overhead? This is what ComponentArrays.jl provides, and as such it is one of the top recommendations of AbstractArray types to be used. Multi-level definitions such as x = ComponentArray(a=5, b=[(a=20., b=0), (a=33., b=0), (a=44., b=3)], c=c) are common-place, and allow for accessing via x.b.a etc. without any performance loss. ComponentArrays are fully compatible with the SciML equation solvers, thus they can be used as initial conditions. Here's a demonstration of the Lorenz equation using ComponentArrays with Parameters.jl's @unpack:","category":"page"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"using ComponentArrays\nusing DifferentialEquations\nusing Parameters: @unpack\n\n\ntspan = (0.0, 20.0)\n\n\n## Lorenz system\nfunction lorenz!(D, u, p, t; f=0.0)\n    @unpack σ, ρ, β = p\n    @unpack x, y, z = u\n\n    D.x = σ*(y - x)\n    D.y = x*(ρ - z) - y - f\n    D.z = x*y - β*z\n    return nothing\nend\n\nlorenz_p = (σ=10.0, ρ=28.0, β=8/3)\nlorenz_ic = ComponentArray(x=0.0, y=0.0, z=0.0)\nlorenz_prob = ODEProblem(lorenz!, lorenz_ic, tspan, lorenz_p)","category":"page"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"Is that beautiful? Yes it is.","category":"page"},{"location":"highlevels/array_libraries/#StaticArrays.jl:-Statically-Defined-Arrays","page":"Modeling Array Libraries","title":"StaticArrays.jl: Statically-Defined Arrays","text":"","category":"section"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"StaticArrays.jl is a library for statically-defined arrays. Because these arrays have type-level information for size, they recompile the solvers for every new size. They can be dramatically faster for small sizes (up to approximately size 10), but for larger equations they increase compile time with little to not benefit.","category":"page"},{"location":"highlevels/array_libraries/#CUDA.jl:-NVIDIA-CUDA-Based-GPU-Array-Computations","page":"Modeling Array Libraries","title":"CUDA.jl: NVIDIA CUDA-Based GPU Array Computations","text":"","category":"section"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"CUDA.jl is the library for defining arrays which live on NVIDIA GPUs (CuArray). SciML's libraries will respect the GPU-ness of the inputs, i.e., if the input arrays live on the GPU then the operations will all take place on the GPU or else the libraries will error if it's unable to do so. Thus using CUDA.jl's CuArray is how one GPU-accelerates any computation with the SciML organization's libraries. Simply use a CuArray as the initial condition to an ODE solve or as the initial guess for a nonlinear solve and the whole solve will recompile to take place on the GPU.","category":"page"},{"location":"highlevels/array_libraries/#AMDGPU.jl:-AMD-Based-GPU-Array-Computations","page":"Modeling Array Libraries","title":"AMDGPU.jl: AMD-Based GPU Array Computations","text":"","category":"section"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"AMDGPU.jl is the library for defining arrays which live on AMD GPUs (ROCArray). SciML's libraries will respect the GPU-ness of the inputs, i.e., if the input arrays live on the GPU then the operations will all take place on the GPU or else the libraries will error if it's unable to do so. Thus using AMDGPU.jl's ROCArray is how one GPU-accelerates any computation with the SciML organization's libraries. Simply use a ROCArray as the initial condition to an ODE solve or as the initial guess for a nonlinear solve and the whole solve will recompile to take place on the GPU.","category":"page"},{"location":"highlevels/array_libraries/#FillArrays.jl:-Lazy-Arrays","page":"Modeling Array Libraries","title":"FillArrays.jl: Lazy Arrays","text":"","category":"section"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"FillArrays.jl is a library for defining arrays with lazy values. For example, an O(1) representation of the identity matrix is given by Eye{Int}(5). FillArrays.jl is used extensively throughout the ecosystem to improve runtime and memory performance.","category":"page"},{"location":"highlevels/array_libraries/#BandedMatrices.jl:-Fast-Banded-Matrices","page":"Modeling Array Libraries","title":"BandedMatrices.jl: Fast Banded Matrices","text":"","category":"section"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"Banded matrices show up in many equation solver contexts, such as the Jacobians of many partial differential equations. While the base SparseMatrixCSC sparse matrix type can represent such matrices, BandedMatrices.jl is a specialized format specifically for BandedMatrices which can be used to greatly improve performance of operations on a banded matrix.","category":"page"},{"location":"highlevels/array_libraries/#BlockBandedMatrices.jl:-Fast-Block-Banded-Matrices","page":"Modeling Array Libraries","title":"BlockBandedMatrices.jl: Fast Block-Banded Matrices","text":"","category":"section"},{"location":"highlevels/array_libraries/","page":"Modeling Array Libraries","title":"Modeling Array Libraries","text":"Block banded matrices show up in many equation solver contexts, such as the Jacobians of many systems of partial differential equations. While the base SparseMatrixCSC sparse matrix type can represent such matrices, BlockBandedMatrices.jl is a specialized format specifically for BlockBandedMatrices which can be used to greatly improve performance of operations on a block-banded matrix.","category":"page"},{"location":"comparisons/r/#r","page":"Getting Started with Julia's SciML for the R User","title":"Getting Started with Julia's SciML for the R User","text":"","category":"section"},{"location":"comparisons/r/","page":"Getting Started with Julia's SciML for the R User","title":"Getting Started with Julia's SciML for the R User","text":"If you're an R user who has looked into Julia, you're probably wondering where all of the scientific computing packages are. How do I solve ODEs? Solve f(x)=0 for x? Etc. SciML is the ecosystem for doing this with Julia.","category":"page"},{"location":"comparisons/r/#Why-SciML?-High-Level-Workflow-Reasons","page":"Getting Started with Julia's SciML for the R User","title":"Why SciML? High-Level Workflow Reasons","text":"","category":"section"},{"location":"comparisons/r/","page":"Getting Started with Julia's SciML for the R User","title":"Getting Started with Julia's SciML for the R User","text":"Performance - The key reason people are moving from R to Julia's SciML in droves is performance. Even simple ODE solvers are much faster!, demonstrating orders of magnitude performance improvements for differential equations, nonlinear solving, optimization, and more. And the performance advantages continue to grow as more complex algorithms are required.\nComposable Library Components - In R environments, every package feels like a silo. Functions made for one file exchange library cannot easily compose with another. SciML's generic coding with JIT compilation these connections create new optimized code on the fly and allow for a more expansive feature set than can ever be documented. Take new high-precision number types from a package and stick them into a nonlinear solver. Take a package for Intel GPU arrays and stick it into the differential equation solver to use specialized hardware acceleration.\nA Global Harmonious Documentation for Scientific Computing - R's documentation for scientific computing is scattered in a bunch of individual packages where the developers do not talk to each other! This not only leads to documentation differences but also \"style\" differences: one package uses tol while the other uses atol. With Julia's SciML, the whole ecosystem is considered together, and inconsistencies are handled at the global level. The goal is to be working in one environment with one language.\nEasier High-Performance and Parallel Computing - With Julia's ecosystem, CUDA will automatically install of the required binaries and cu(A)*cu(B) is then all that's required to GPU-accelerate large-scale linear algebra. MPI is easy to install and use. Distributed computing through password-less SSH. Multithreading is automatic and baked into a lot of libraries, with a specialized algorithm to ensure hierarchical usage does not oversubscribe threads. Basically, libraries give you a lot of parallelism for free, and doing the rest is a piece of cake.\nMix Scientific Computing with Machine Learning - Want to automate the discovery of missing physical laws using neural networks embedded in differentiable simulations? Julia's SciML is the ecosystem with the tooling to integrate machine learning into the traditional high-performance scientific computing domains, from multiphysics simulations to partial differential equations.","category":"page"},{"location":"comparisons/r/","page":"Getting Started with Julia's SciML for the R User","title":"Getting Started with Julia's SciML for the R User","text":"In this plot, deSolve in blue represents R's most commonly used solver:","category":"page"},{"location":"comparisons/r/","page":"Getting Started with Julia's SciML for the R User","title":"Getting Started with Julia's SciML for the R User","text":"(Image: )","category":"page"},{"location":"comparisons/r/#Need-Help-Translating-from-R-to-Julia?","page":"Getting Started with Julia's SciML for the R User","title":"Need Help Translating from R to Julia?","text":"","category":"section"},{"location":"comparisons/r/","page":"Getting Started with Julia's SciML for the R User","title":"Getting Started with Julia's SciML for the R User","text":"The following resources can be particularly helpful when adopting Julia for SciML for the first time:","category":"page"},{"location":"comparisons/r/","page":"Getting Started with Julia's SciML for the R User","title":"Getting Started with Julia's SciML for the R User","text":"The Julia Manual's Noteworthy Differences from R page\nTutorials on Data Wrangling and Plotting in Julia (Sections 4 and 5) written for folks with a background in R.\nDouble check your results with deSolveDiffEq.jl (automatically converts and runs ODE definitions with R's deSolve solvers)\nUse RCall.jl to more incrementally move code to Julia.\nComparisons between R and Julia from the DataFrames package. And an accessible starting point for Julia's DataFrames.","category":"page"},{"location":"comparisons/r/#R-to-Julia-SciML-Functionality-Translations","page":"Getting Started with Julia's SciML for the R User","title":"R to Julia SciML Functionality Translations","text":"","category":"section"},{"location":"comparisons/r/","page":"Getting Started with Julia's SciML for the R User","title":"Getting Started with Julia's SciML for the R User","text":"The following chart will help you get quickly acquainted with Julia's SciML Tools:","category":"page"},{"location":"comparisons/r/","page":"Getting Started with Julia's SciML for the R User","title":"Getting Started with Julia's SciML for the R User","text":"R Function/Package SciML-Supported Julia packages\ndata.frame DataFrames\nplot Plots, Makie\nggplot2 AlgebraOfGraphics\ndeSolve DifferentialEquations\nStan Turing","category":"page"},{"location":"comparisons/r/#Want-to-See-the-Power-of-Julia?","page":"Getting Started with Julia's SciML for the R User","title":"Want to See the Power of Julia?","text":"","category":"section"},{"location":"comparisons/r/","page":"Getting Started with Julia's SciML for the R User","title":"Getting Started with Julia's SciML for the R User","text":"Check out this R-Bloggers blog post on diffeqr, a package which uses ModelingToolkit to translate R code to Julia, and achieves 350x acceleration over R's popular deSolve ODE solver package. But when the solve is done purely in Julia, it achieves 2777x acceleration over deSolve!","category":"page"},{"location":"highlevels/equation_solvers/#Equation-Solvers","page":"Equation Solvers","title":"Equation Solvers","text":"","category":"section"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"The SciML Equation Solvers cover a large set of SciMLProblems with SciMLAlgorithms that are efficient, numerically stable, and flexible. These methods tie into libraries like SciMLSensitivity.jl to be fully differentiable and compatible with machine learning pipelines, and are designed for integration with applications like parameter estimation, global sensitivity analysis, and more.","category":"page"},{"location":"highlevels/equation_solvers/#LinearSolve.jl:-Unified-Interface-for-Linear-Solvers","page":"Equation Solvers","title":"LinearSolve.jl: Unified Interface for Linear Solvers","text":"","category":"section"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"LinearSolve.jl is the canonical library for solving LinearProblems. It includes:","category":"page"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"Fast pure Julia LU factorizations which outperform standard BLAS\nKLU for faster sparse LU factorization on unstructured matrices\nUMFPACK for faster sparse LU factorization on matrices with some repeated structure\nMKLPardiso wrappers for handling many sparse matrices faster than SuiteSparse (KLU, UMFPACK) methods\nGPU-offloading for large dense matrices\nWrappers to all of the Krylov implementations (Krylov.jl, IterativeSolvers.jl, KrylovKit.jl) for easy testing of all of them. LinearSolve.jl handles the API differences, especially with the preconditioner definitions\nA polyalgorithm that smartly chooses between these methods\nA caching interface which automates caching of symbolic factorizations and numerical factorizations as optimally as possible\nCompatible with arbitrary AbstractArray and Number types, such as GPU-based arrays, uncertainty quantification number types, and more.","category":"page"},{"location":"highlevels/equation_solvers/#NonlinearSolve.jl:-Unified-Interface-for-Nonlinear-Solvers","page":"Equation Solvers","title":"NonlinearSolve.jl: Unified Interface for Nonlinear Solvers","text":"","category":"section"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"NonlinearSolve.jl is the canonical library for solving NonlinearProblems. It includes:","category":"page"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"Fast non-allocating implementations on static arrays of common methods (Newton-Rhapson)\nBracketing methods (Bisection, Falsi) for methods with known upper and lower bounds\nWrappers to common other solvers (NLsolve.jl, MINPACK, KINSOL from Sundials) for trust region methods, line search based approaches, etc.\nBuilt over the LinearSolve.jl API for maximum flexibility and performance in the solving approach\nCompatible with arbitrary AbstractArray and Number types, such as GPU-based arrays, uncertainty quantification number types, and more.","category":"page"},{"location":"highlevels/equation_solvers/#DifferentialEquations.jl:-Unified-Interface-for-Differential-Equation-Solvers","page":"Equation Solvers","title":"DifferentialEquations.jl: Unified Interface for Differential Equation Solvers","text":"","category":"section"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"DifferentialEquations.jl is the canonical library for solving DEProblems. This includes:","category":"page"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"Discrete equations (function maps, discrete stochastic (Gillespie/Markov) simulations) (DiscreteProblem)\nOrdinary differential equations (ODEs) (ODEProblem)\nSplit and Partitioned ODEs (Symplectic integrators, IMEX Methods) (SplitODEProblem)\nStochastic ordinary differential equations (SODEs or SDEs) (SDEProblem)\nStochastic differential-algebraic equations (SDAEs) (SDEProblem with mass matrices)\nRandom differential equations (RODEs or RDEs) (RODEProblem)\nDifferential algebraic equations (DAEs) (DAEProblem and ODEProblem with mass matrices)\nDelay differential equations (DDEs) (DDEProblem)\nNeutral, retarded, and algebraic delay differential equations (NDDEs, RDDEs, and DDAEs)\nStochastic delay differential equations (SDDEs) (SDDEProblem)\nExperimental support for stochastic neutral, retarded, and algebraic delay differential equations (SNDDEs, SRDDEs, and SDDAEs)\nMixed discrete and continuous equations (Hybrid Equations, Jump Diffusions) (DEProblems with callbacks and JumpProblem)","category":"page"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"The well-optimized DifferentialEquations solvers benchmark as some of the fastest implementations of classic algorithms. It also includes algorithms from recent research which routinely outperform the \"standard\" C/Fortran methods, and algorithms optimized for high-precision and HPC applications. Simultaneously, it wraps the classic C/Fortran methods, making it easy to switch over to them whenever necessary. Solving differential equations with different methods from different languages and packages can be done by changing one line of code, allowing for easy benchmarking to ensure you are using the fastest method possible.","category":"page"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"DifferentialEquations.jl integrates with the Julia package sphere with:","category":"page"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"GPU acceleration through CUDAnative.jl and CuArrays.jl\nAutomated sparsity detection with Symbolics.jl\nAutomatic Jacobian coloring with SparseDiffTools.jl, allowing for fast solutions to problems with sparse or structured (Tridiagonal, Banded, BlockBanded, etc.) Jacobians\nAllowing the specification of linear solvers for maximal efficiency\nProgress meter integration with the Juno IDE for estimated time to solution\nAutomatic plotting of time series and phase plots\nBuilt-in interpolations\nWraps for common C/Fortran methods, like Sundials and Hairer's radau\nArbitrary precision with BigFloats and Arbfloats\nArbitrary array types, allowing the definition of differential equations on matrices and distributed arrays\nUnit-checked arithmetic with Unitful","category":"page"},{"location":"highlevels/equation_solvers/#Optimization.jl:-Unified-Interface-for-Optimization","page":"Equation Solvers","title":"Optimization.jl: Unified Interface for Optimization","text":"","category":"section"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"Optimization.jl is the canonical library for solving OptimizationProblems. It includes wrappers of most of the Julia nonlinear optimization ecosystem, allowing one syntax to use all packages in a uniform manner. This covers:","category":"page"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"OptimizationBBO for BlackBoxOptim.jl\nOptimizationEvolutionary for Evolutionary.jl (see also this documentation)\nOptimizationGCMAES for GCMAES.jl\nOptimizationMOI for MathOptInterface.jl (usage of algorithm via MathOptInterface API; see also the API documentation)\nOptimizationMetaheuristics for Metaheuristics.jl (see also this documentation)\nOptimizationMultistartOptimization for MultistartOptimization.jl (see also this documentation)\nOptimizationNLopt for NLopt.jl (usage via the NLopt API; see also the available algorithms)\nOptimizationNOMAD for NOMAD.jl (see also this documentation)\nOptimizationNonconvex for Nonconvex.jl (see also this documentation)\nOptimizationQuadDIRECT for QuadDIRECT.jl\nOptimizationSpeedMapping for SpeedMapping.jl (see also this documentation)","category":"page"},{"location":"highlevels/equation_solvers/#Integrals.jl:-Unified-Interface-for-Numerical-Integration","page":"Equation Solvers","title":"Integrals.jl: Unified Interface for Numerical Integration","text":"","category":"section"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"Integrals.jl is the canonical library for solving IntegralsProblems. It includes wrappers of most of the Julia quadrature ecosystem, allowing one syntax to use all packages in a uniform manner. This covers:","category":"page"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"Gauss-Kronrod quadrature\nCubature methods (both h and p cubature)\nAdaptive Monte Carlo methods","category":"page"},{"location":"highlevels/equation_solvers/#JumpProcesses.jl:-Stochastic-Simulation-Algorithms-for-Jump-Processes,-Jump-ODEs,-and-Jump-Diffusions","page":"Equation Solvers","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"","category":"section"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"JumpProcesses.jl is the library for Poisson jump processes, also known as chemical master equations or Gillespie simulations, for simulating chemical reaction networks and other applications. It allows for solving with many methods, including:","category":"page"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"Direct: the Gillespie Direct method SSA.\nRDirect: A variant of Gillespie's Direct method that uses rejection to sample the next reaction.\nDirectCR: The Composition-Rejection Direct method of Slepoy et al. For large networks and linear chain-type networks it will often give better performance than Direct. (Requires dependency graph, see below.)\nDirectFW: the Gillespie Direct method SSA with FunctionWrappers. This aggregator uses a different internal storage format for collections of ConstantRateJumps.\nFRM: the Gillespie first reaction method SSA. Direct should generally offer better performance and be preferred to FRM.\nFRMFW: the Gillespie first reaction method SSA with FunctionWrappers.\nNRM: The Gibson-Bruck Next Reaction Method. For some reaction network  structures this may offer better performance than Direct (for example,  large, linear chains of reactions). (Requires dependency graph, see below.)\nRSSA: The Rejection SSA (RSSA) method of Thanh et al. With RSSACR, for very large reaction networks it often offers the best performance of all methods. (Requires dependency graph, see below.)\nRSSACR: The Rejection SSA (RSSA) with Composition-Rejection method of Thanh et al. With RSSA, for very large reaction networks it often offers the best performance of all methods. (Requires dependency graph, see below.)\nSortingDirect: The Sorting Direct Method of McCollum et al. It will usually offer performance as good as Direct, and for some systems can offer substantially better performance. (Requires dependency graph, see below.)","category":"page"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"The design of JumpProcesses.jl composes with DifferentialEquations.jl, allowing for discrete stochastic chemical reactions to be easily mixed with differential equation models, allowing for simulation of hybrid systems, jump diffusions, and differential equations driven by Levy processes.","category":"page"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"In addition, JumpProcesses's interfaces allow for solving with regular jump methods, such as adaptive Tau-Leaping.","category":"page"},{"location":"highlevels/equation_solvers/#Third-Party-Libraries-to-Note","page":"Equation Solvers","title":"Third Party Libraries to Note","text":"","category":"section"},{"location":"highlevels/equation_solvers/#JuMP.jl:-Julia-for-Mathematical-Programming","page":"Equation Solvers","title":"JuMP.jl: Julia for Mathematical Programming","text":"","category":"section"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"While Optimization.jl is the preferred library for nonlinear optimization, for all other forms of optimization Julia for Mathematical Programming (JuMP) is the star. JuMP is the leading choice in Julia for doing:","category":"page"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"Linear Programming\nQuadratic Programming\nConvex Programming\nConic Programming\nSemidefinite Programming\nMixed-Complementarity Programming\nInteger Programming\nMixed Integer (nonlinear/linear) Programming\n(Mixed Integer) Second Order Conic Programming","category":"page"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"JuMP can also be used for some nonlinear programming, though the Optimization.jl bindings to the JuMP solvers (via MathOptInterface.jl) is generally preferred.","category":"page"},{"location":"highlevels/equation_solvers/#FractionalDiffEq.jl:-Fractional-Differential-Equation-Solvers","page":"Equation Solvers","title":"FractionalDiffEq.jl: Fractional Differential Equation Solvers","text":"","category":"section"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"FractionalDiffEq.jl is a set of high-performance solvers for fractional differential equations.","category":"page"},{"location":"highlevels/equation_solvers/#ManifoldDiffEq.jl:-Solvers-for-Differential-Equations-on-Manifolds","page":"Equation Solvers","title":"ManifoldDiffEq.jl: Solvers for Differential Equations on Manifolds","text":"","category":"section"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"ManifoldDiffEq.jl is a set of high-performance solvers for differential equations on manifolds using methods such as Lie Group actions and frozen coefficients (Crouch-Grossman methods). These solvers can in many cases out-perform the OrdinaryDiffEq.jl nonautonomous operator ODE solvers by using methods specialized on manifold definitions of ManifoldsBase.","category":"page"},{"location":"highlevels/equation_solvers/#Manopt.jl:-Optimization-on-Manifolds","page":"Equation Solvers","title":"Manopt.jl: Optimization on Manifolds","text":"","category":"section"},{"location":"highlevels/equation_solvers/","page":"Equation Solvers","title":"Equation Solvers","text":"ManOpt.jl allows for easy and efficient solving of nonlinear optimization problems on manifolds.","category":"page"},{"location":"comparisons/matlab/#matlab","page":"Getting Started with  Julia's SciML for the MATLAB User","title":"Getting Started with  Julia's SciML for the MATLAB User","text":"","category":"section"},{"location":"comparisons/matlab/","page":"Getting Started with  Julia's SciML for the MATLAB User","title":"Getting Started with  Julia's SciML for the MATLAB User","text":"If you're a MATLAB user who has looked into Julia for some performance improvements, you may have noticed that the standard library does not have all of the \"batteries\" included with a base MATLAB installation. Where's the ODE solver? Where's fmincon and fsolve? Those scientific computing functionalities are the pieces provided by the Julia SciML ecosystem!","category":"page"},{"location":"comparisons/matlab/#Why-SciML?-High-Level-Workflow-Reasons","page":"Getting Started with  Julia's SciML for the MATLAB User","title":"Why SciML? High-Level Workflow Reasons","text":"","category":"section"},{"location":"comparisons/matlab/","page":"Getting Started with  Julia's SciML for the MATLAB User","title":"Getting Started with  Julia's SciML for the MATLAB User","text":"Performance - The key reason people are moving from MATLAB to Julia's SciML in droves is performance. Even simple ODE solvers are much faster!, demonstrating orders of magnitude performance improvements for differential equations, nonlinear solving, optimization, and more. And the performance advantages continue to grow as more complex algorithms are required.\nJulia is quick to learn from MATLAB - Most ODE codes can be translated in a few minutes. If you need help, check out the QuantEcon MATLAB-Python-Julia Cheatsheet\nPackage Management and Versioning - Julia's package manager takes care of dependency management, testing, and continuous delivery in order to make the installation and maintenance process smoother. For package users, this means it's easier to get packages with complex functionality in your hands.\nFree and Open Source - If you want to know how things are being computed, just look at our Github organization. Lots of individuals use Julia's SciML to research how the algorithms actually work because of how accessible and tweakable the ecosystem is!\nComposable Library Components - In MATLAB environments, every package feels like a silo. Functions made for one file exchange library cannot easily compose with another. SciML's generic coding with JIT compilation these connections create new optimized code on the fly and allow for a more expansive feature set than can ever be documented. Take new high-precision number types from a package and stick them into a nonlinear solver. Take a package for Intel GPU arrays and stick it into the differential equation solver to use specialized hardware acceleration.\nEasier High-Performance and Parallel Computing - With Julia's ecosystem, CUDA will automatically install of the required binaries and cu(A)*cu(B) is then all that's required to GPU-accelerate large-scale linear algebra. MPI is easy to install and use. Distributed computing through password-less SSH. Multithreading is automatic and baked into a lot of libraries, with a specialized algorithm to ensure hierarchical usage does not oversubscribe threads. Basically, libraries give you a lot of parallelism for free, and doing the rest is a piece of cake.\nMix Scientific Computing with Machine Learning - Want to automate the discovery of missing physical laws using neural networks embedded in differentiable simulations? Julia's SciML is the ecosystem with the tooling to integrate machine learning into the traditional high-performance scientific computing domains, from multiphysics simulations to partial differential equations.","category":"page"},{"location":"comparisons/matlab/","page":"Getting Started with  Julia's SciML for the MATLAB User","title":"Getting Started with  Julia's SciML for the MATLAB User","text":"In this plot, MATLAB in orange represents MATLAB's most commonly used solvers:","category":"page"},{"location":"comparisons/matlab/","page":"Getting Started with  Julia's SciML for the MATLAB User","title":"Getting Started with  Julia's SciML for the MATLAB User","text":"(Image: )","category":"page"},{"location":"comparisons/matlab/#Need-a-case-study?","page":"Getting Started with  Julia's SciML for the MATLAB User","title":"Need a case study?","text":"","category":"section"},{"location":"comparisons/matlab/","page":"Getting Started with  Julia's SciML for the MATLAB User","title":"Getting Started with  Julia's SciML for the MATLAB User","text":"Check out this talk from NASA Scientists getting a 15,000x acceleration by switching from Simulink to Julia's ModelingToolkit!.","category":"page"},{"location":"comparisons/matlab/#Need-Help-Translating-from-MATLAB-to-Julia?","page":"Getting Started with  Julia's SciML for the MATLAB User","title":"Need Help Translating from MATLAB to Julia?","text":"","category":"section"},{"location":"comparisons/matlab/","page":"Getting Started with  Julia's SciML for the MATLAB User","title":"Getting Started with  Julia's SciML for the MATLAB User","text":"The following resources can be particularly helpful when adopting Julia for SciML for the first time:","category":"page"},{"location":"comparisons/matlab/","page":"Getting Started with  Julia's SciML for the MATLAB User","title":"Getting Started with  Julia's SciML for the MATLAB User","text":"QuantEcon MATLAB-Python-Julia Cheatsheet\nThe Julia Manual's Noteworthy Differences from MATLAB page\nDouble check your results with MATLABDiffEq.jl (automatically converts and runs ODE definitions with MATLAB's solvers)\nUse MATLAB.jl to more incrementally move code to Julia.","category":"page"},{"location":"comparisons/matlab/#MATLAB-to-Julia-SciML-Functionality-Translations","page":"Getting Started with  Julia's SciML for the MATLAB User","title":"MATLAB to Julia SciML Functionality Translations","text":"","category":"section"},{"location":"comparisons/matlab/","page":"Getting Started with  Julia's SciML for the MATLAB User","title":"Getting Started with  Julia's SciML for the MATLAB User","text":"The following chart will help you get quickly acquainted with Julia's SciML Tools:","category":"page"},{"location":"comparisons/matlab/","page":"Getting Started with  Julia's SciML for the MATLAB User","title":"Getting Started with  Julia's SciML for the MATLAB User","text":"MATLAB Function SciML-Supported Julia packages\nplot Plots, Makie\nsparse SparseArrays\ninterp1 DataInterpolations\n\\, gmres, cg LinearSolve\nfsolve NonlinearSolve\nquad Integrals\nfmincon Optimization\nodeXX DifferentialEquations\node45 Tsit5\node113 VCABM\node23s Rosenbrock23\node15s QNDF or FBDF\node15i IDA\nbvp4c and bvp5c DifferentialEquations\nSimulink, Simscape ModelingToolkit\nfft FFTW\nchebfun ApproxFun","category":"page"},{"location":"getting_started/integral_approx/#integral_approx","page":"Numerically approximate an integral","title":"Numerically approximate an integral","text":"","category":"section"},{"location":"highlevels/inverse_problems/#parameter_estimation","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"","category":"section"},{"location":"highlevels/inverse_problems/","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"Parameter estimation for models and equations, also known as dynamic data analysis, solving the inverse problem, or Bayesian posterior estimation (when done probabilistically), is provided by the SciML tools for the equations in its set. In this introduction, we briefly present the relevant packages that facilitate parameter estimation, namely:","category":"page"},{"location":"highlevels/inverse_problems/","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"SciMLSensitivity.jl\nDiffEqFlux.jl\nTuring.jl\nDataDrivenDiffEq.jl\nDiffEqParamEstim.jl\nDiffEqBayes.jl","category":"page"},{"location":"highlevels/inverse_problems/","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"We also provide information regarding the respective strengths of these packages so that you can easily decide which one suits your needs best.","category":"page"},{"location":"highlevels/inverse_problems/#SciMLSensitivity.jl:-Local-Sensitivity-Analysis-and-Automatic-Differentiation-Support-for-Solvers","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"SciMLSensitivity.jl: Local Sensitivity Analysis and Automatic Differentiation Support for Solvers","text":"","category":"section"},{"location":"highlevels/inverse_problems/","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"SciMLSensitivity.jl is the system for local sensitivity analysis which all other inverse problem methods rely on. This package defines the interactions between the equation solvers and automatic differentiation, defining fast overloads for forward and adjoint (reverse) sensitivity analysis for fast gradient and Jacobian calculations with respect to model inputs. Its documentation covers how to use direct differentiation of equation solvers in conjunction with tools like Optimization.jl to perform model calibration of ODEs against data, PDE-constrained optimization, nonlinear optimal controls analysis, and much more. As a lower level tool, this library is very versatile, feature-rich, and high-performance, giving all of the tools required but not directly providing a higher level interface.","category":"page"},{"location":"highlevels/inverse_problems/","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"note: Note\nSensitivity analysis is kept in a separate library from the solvers (SciMLSensitivity.jl), in order to not require all equation solvers to have a dependency on all automatic differentiation libraries. If automatic differentiation is applied to a solver library without importing SciMLSensitivity.jl, an error is thrown letting the user know to import SciMLSensitivity.jl for the functionality to exist.","category":"page"},{"location":"highlevels/inverse_problems/#DataDrivenDiffEq.jl:-Data-Driven-Modeling-and-Equation-Discovery","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"DataDrivenDiffEq.jl: Data-Driven Modeling and Equation Discovery","text":"","category":"section"},{"location":"highlevels/inverse_problems/","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"The distinguishing feature of this package is that its ultimate goal is to identify the differential equation model that generated the input data. Depending on the user's needs, the package can provide structural identification of a given differential equation (output in a symbolic form) or structural estimation (output as a function for prediction purposes).","category":"page"},{"location":"highlevels/inverse_problems/#DiffEqParamEstim.jl:-Simplified-Parameter-Estimation-Interface","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"DiffEqParamEstim.jl: Simplified Parameter Estimation Interface","text":"","category":"section"},{"location":"highlevels/inverse_problems/","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"This package is for simplified parameter estimation. While not as flexible of a system like DiffEqFlux.jl, it provides ready-made functions for doing standard optimization procedures like L2 fitting and MAP estimates. Among other features, it allows for the optimization of parameters in ODEs, stochastic problems, and delay differential equations.","category":"page"},{"location":"highlevels/inverse_problems/#DiffEqBayes.jl:-Simplified-Bayesian-Estimation-Interface","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"DiffEqBayes.jl: Simplified Bayesian Estimation Interface","text":"","category":"section"},{"location":"highlevels/inverse_problems/","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"As the name suggests, this package has been designed to provide the estimation of differential equations parameters by means of Bayesian methods. It works in conjunction with Turing.jl, CmdStan.jl, DynamicHMC.jl, and ApproxBayes.jl. While not as flexible as direct usage of DiffEqFlux.jl or Turing.jl, DiffEqBayes.jl can be an approachable interface for those not familiar with Bayesian estimation, and provides a nice way to use Stan from pure Julia.","category":"page"},{"location":"highlevels/inverse_problems/#Third-Party-Tools-of-Note","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Third Party Tools of Note","text":"","category":"section"},{"location":"highlevels/inverse_problems/#Turing.jl:-A-Flexible-Probabilistic-Programming-Language-for-Bayesian-Analysis","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Turing.jl: A Flexible Probabilistic Programming Language for Bayesian Analysis","text":"","category":"section"},{"location":"highlevels/inverse_problems/","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"In the context of differential equations and parameter estimation, Turing.jl allows for a Bayesian estimation of differential equations (used in conjunction with the high-level package DiffEqBayes.jl). For more examples on combining Turing.jl with DiffEqBayes.jl, see the documentation below. It is important to note that Turing.jl can also perform Bayesian estimation without relying on DiffEqBayes.jl (for an example, consult this tutorial).","category":"page"},{"location":"highlevels/inverse_problems/#Topopt.jl:-Topology-Optimization-in-Julia","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Topopt.jl: Topology Optimization in Julia","text":"","category":"section"},{"location":"highlevels/inverse_problems/","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"Topopt.jl solves topology optimization problems which are inverse problems on partial differential equations, solving for an optimal domain.","category":"page"},{"location":"highlevels/inverse_problems/#Recommended-Automatic-Differentiation-Libraries","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Recommended Automatic Differentiation Libraries","text":"","category":"section"},{"location":"highlevels/inverse_problems/","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"Solving inverse problems commonly requires using automatic differentiation (AD). SciML includes extensive support for automatic differentiation throughout its solvers, though some AD libraries are more tested than others. The following libraries are the current recommendations of the SciML developers.","category":"page"},{"location":"highlevels/inverse_problems/#ForwardDiff.jl:-Operator-Overloading-Forward-Mode-Automatic-Differentiation","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"ForwardDiff.jl: Operator-Overloading Forward Mode Automatic Differentiation","text":"","category":"section"},{"location":"highlevels/inverse_problems/","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"ForwardDiff.jl is a library for operator-overloading based forward-mode automatic differentiation. It's commonly used as the default method for generating Jacobians throughout the SciML solver libraries.","category":"page"},{"location":"highlevels/inverse_problems/","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"note: Note\nBecause ForwardDiff.jl uses an operator overloading approach, uses of ForwardDiff.jl require that any caches for non-allocating mutating code allows for Dual numbers. To allow such code to be ForwardDiff.jl-compatible, see PreallocationTools.jl.","category":"page"},{"location":"highlevels/inverse_problems/#Enzyme.jl:-LLVM-Level-Forward-and-Reverse-Mode-Automatic-Differentiation","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Enzyme.jl: LLVM-Level Forward and Reverse Mode Automatic Differentiation","text":"","category":"section"},{"location":"highlevels/inverse_problems/","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"Enzyme.jl is an LLVM-level AD library for forward and reverse automatic differentiation. It supports many features required for high performance, such as being able to differentiate mutating and interleave compiler optimization with the AD passes. However, it does not support all of the Julia runtime, and thus some code with many dynamic behaviors and garbage collection (GC) invocations can be incompatible with Enzyme. Enzyme.jl is quickly becoming the new standard AD for SciML.","category":"page"},{"location":"highlevels/inverse_problems/#Zygote.jl:-Julia-Level-Source-to-Source-Reverse-Mode-Automatic-Differentiation","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Zygote.jl: Julia-Level Source-to-Source Reverse Mode Automatic Differentiation","text":"","category":"section"},{"location":"highlevels/inverse_problems/","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"Zygote.jl is the current standard user-level reverse-mode automatic differentiation library for the SciML solvers. User-level means that many library tutorials, like in SciMLSensitivity.jl and DiffEqFlux.jl, are written showcase user code using Zygote.jl. This is because Zygote.jl is the AD engine associated with the Flux machine learning library. However, Zygote.jl has many limitations which limits its performance in equation solver contexts, such as an inability to handle mutation and introducing many small allocations and type-instabilities. For this reason, the SciML equation solvers include define differentiation overloads using ChainRules.jl, meaning that the equation solvers tend to not use Zygote.jl internally even if the user code uses Zygote.gradient. In this manner, the speed and performance of more advanced techniques can be preserved while using the Julia standard.","category":"page"},{"location":"highlevels/inverse_problems/#FiniteDiff.jl:-Fast-Finite-Difference-Approximations","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"FiniteDiff.jl: Fast Finite Difference Approximations","text":"","category":"section"},{"location":"highlevels/inverse_problems/","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"FiniteDiff.jl is the preferred fallback library for numerical differentiation and is commonly used by SciML solver libraries when automatic differentiation is disabled.","category":"page"},{"location":"highlevels/inverse_problems/#SparseDiffTools.jl:-Tools-for-Fast-Automatic-Differentiation-with-Sparse-Operators","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"SparseDiffTools.jl: Tools for Fast Automatic Differentiation with Sparse Operators","text":"","category":"section"},{"location":"highlevels/inverse_problems/","page":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","title":"Parameter Estimation, Bayesian Analysis, and Inverse Problems","text":"SparseDiffTools.jl is a library for sparse automatic differentiation. It's used internally by many of the SciML equation solver libraries, which explicitly expose interfaces for colorvec color vectors generated by SparseDiffTools.jl's methods. SparseDiffTools.jl also includes many features useful to users, such as operators for matrix-free Jacobian-vector and Hessian-vector products.","category":"page"},{"location":"getting_started/find_root/#find_root","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Find the root of an equation (i.e. solve f(x)=0)","text":"","category":"section"},{"location":"getting_started/find_root/","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Find the root of an equation (i.e. solve f(x)=0)","text":"A nonlinear system f(u) = 0 is specified by defining a function f(u,p), where p are the parameters of the system. Many problems can be written in such as way that solving a nonlinear rootfinding problem gives the solution. For example: ","category":"page"},{"location":"getting_started/find_root/","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Find the root of an equation (i.e. solve f(x)=0)","text":"Do you want to know u such that 4^u + 6^u = 7^u? Then solve  f(u) = 4^u + 6^u - 7^u = 0 for u!\nIf you have an ODE u = f(u), what is the point where the solution will be completely still, i.e. u' = 0?\n","category":"page"},{"location":"getting_started/find_root/","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Find the root of an equation (i.e. solve f(x)=0)","text":"All of these problems are solved by using a numerical rootfinder. Let's solve  our first rootfind problem!","category":"page"},{"location":"getting_started/find_root/#Problem-Setup","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Problem Setup","text":"","category":"section"},{"location":"getting_started/find_root/","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Find the root of an equation (i.e. solve f(x)=0)","text":"For example, the following solves the vector equation:","category":"page"},{"location":"getting_started/find_root/","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Find the root of an equation (i.e. solve f(x)=0)","text":"beginaligned\n0 = σ*(y-x)\n0 = x*(ρ-z)-y\n0 = x*y - β*z\nendaligned","category":"page"},{"location":"getting_started/find_root/","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Find the root of an equation (i.e. solve f(x)=0)","text":"With the parameter values sigma = 100, rho = 260, beta = 83.","category":"page"},{"location":"getting_started/find_root/","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Find the root of an equation (i.e. solve f(x)=0)","text":"# Import the packages\nusing ModelingToolkit, NonlinearSolve\n\n# Define the nonlinear system\n@variables x=1.0 y=0.0 z=0.0\n@parameters σ=10.0 ρ=26.0 β=8/3\n\neqs = [0 ~ σ*(y-x),\n       0 ~ x*(ρ-z)-y,\n       0 ~ x*y - β*z]\n@named ns = NonlinearSystem(eqs, [x,y,z], [σ,ρ,β])\n\n# Convert the symbolic system into a numerical system\nprob = NonlinearProblem(ns,[])\n\n# Solve the numerical problem\nsol = solve(prob,NewtonRaphson())\n\n# Analyze the solution\n@show sol.u, prob.f(sol.u,prob.p)","category":"page"},{"location":"getting_started/find_root/#Step-1:-Import-the-Packages","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Step 1: Import the Packages","text":"","category":"section"},{"location":"getting_started/find_root/","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Find the root of an equation (i.e. solve f(x)=0)","text":"# Import the packages\nusing ModelingToolkit, NonlinearSolve","category":"page"},{"location":"getting_started/find_root/#Step-2:-Define-the-Nonlinear-System","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Step 2: Define the Nonlinear System","text":"","category":"section"},{"location":"getting_started/find_root/","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Find the root of an equation (i.e. solve f(x)=0)","text":"# Define the nonlinear system\n@variables x=1.0 y=0.0 z=0.0\n@parameters σ=10.0 ρ=26.0 β=8/3\n\neqs = [0 ~ σ*(y-x),\n       0 ~ x*(ρ-z)-y,\n       0 ~ x*y - β*z]\n@named ns = NonlinearSystem(eqs, [x,y,z], [σ,ρ,β])","category":"page"},{"location":"getting_started/find_root/#Step-3:-Convert-the-Symbolic-Problem-to-a-Numerical-Problem","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Step 3: Convert the Symbolic Problem to a Numerical Problem","text":"","category":"section"},{"location":"getting_started/find_root/","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Find the root of an equation (i.e. solve f(x)=0)","text":"# Convert the symbolic system into a numerical system\nprob = NonlinearProblem(ns,[])","category":"page"},{"location":"getting_started/find_root/#Step-4:-Solve-the-Numerical-Problem","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Step 4: Solve the Numerical Problem","text":"","category":"section"},{"location":"getting_started/find_root/","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Find the root of an equation (i.e. solve f(x)=0)","text":"# Solve the numerical problem\nsol = solve(prob,NewtonRaphson())","category":"page"},{"location":"getting_started/find_root/#Step-5:-Analyze-the-Solution","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Step 5: Analyze the Solution","text":"","category":"section"},{"location":"getting_started/find_root/","page":"Find the root of an equation (i.e. solve f(x)=0)","title":"Find the root of an equation (i.e. solve f(x)=0)","text":"# Analyze the solution\n@show sol.u, prob.f(sol.u,prob.p)","category":"page"},{"location":"highlevels/uncertainty_quantification/#Uncertainty-Quantification","page":"Uncertainty Quantification","title":"Uncertainty Quantification","text":"","category":"section"},{"location":"highlevels/uncertainty_quantification/","page":"Uncertainty Quantification","title":"Uncertainty Quantification","text":"There's always uncertainty in our models. Whether it's in the form of the model's equations or in the model's parameters, the uncertainty in our simulation's output often needs to be quantified. The following tools automate this process.","category":"page"},{"location":"highlevels/uncertainty_quantification/","page":"Uncertainty Quantification","title":"Uncertainty Quantification","text":"For Measurements.jl vs MonteCarloMeasurements.jl vs Intervals.jl, and the relation to other methods, see the Uncertainty Programming chapter of the SciML Book.","category":"page"},{"location":"highlevels/uncertainty_quantification/#PolyChaos.jl:-Intrusive-Polynomial-Chaos-Expansions-Made-Unintrusive","page":"Uncertainty Quantification","title":"PolyChaos.jl: Intrusive Polynomial Chaos Expansions Made Unintrusive","text":"","category":"section"},{"location":"highlevels/uncertainty_quantification/","page":"Uncertainty Quantification","title":"Uncertainty Quantification","text":"PolyChaos.jl is a library for calculating intrusive polynomial chaos expansions (PCE) on arbitrary Julia functions. This allows for inputing representations of probability distributions into functions to compute the output distribution in an expansion representation. While normally this would require deriving the PCE-expanded equations by hand, PolyChaos.jl does this at the compiler level using Julia's multiple dispatch, giving a high-performance implementation to a normally complex and tedious mathematical transformation.","category":"page"},{"location":"highlevels/uncertainty_quantification/#SciMLExpectations.jl:-Fast-Calculations-of-Expectations-of-Equation-Solutions","page":"Uncertainty Quantification","title":"SciMLExpectations.jl: Fast Calculations of Expectations of Equation Solutions","text":"","category":"section"},{"location":"highlevels/uncertainty_quantification/","page":"Uncertainty Quantification","title":"Uncertainty Quantification","text":"SciMLExpectations.jl is a library for accelerating the calculation of expectations of equation solutions with respect to input probability distributions, allowing for applications like robust optimization with respect to uncertainty. It uses Koopman operator techniques to calculate these expectations without requiring the propagation of uncertainties through a solver, effectively performing the adjoint of uncertainty quantification and being much more efficient in the process.","category":"page"},{"location":"highlevels/uncertainty_quantification/#Third-Party-Libraries-to-Note","page":"Uncertainty Quantification","title":"Third Party Libraries to Note","text":"","category":"section"},{"location":"highlevels/uncertainty_quantification/#Measurements.jl:-Automated-Linear-Error-Propagation","page":"Uncertainty Quantification","title":"Measurements.jl: Automated Linear Error Propagation","text":"","category":"section"},{"location":"highlevels/uncertainty_quantification/","page":"Uncertainty Quantification","title":"Uncertainty Quantification","text":"Measurements.jl is a library for automating linear error propagation. Uncertain numbers are defined as x = 3.8 ± 0.4 and are pushed through calculations using a normal distribution approximation in order to compute an approximate uncertain output. Measurements.jl uses a dictionary-based approach to keep track of correlations to improve the accuracy over naive implementations, though note that linear error propagation theory still has some major issues handling some types of equations as described in detail in the MonteCarloMeasurements.jl documentation.","category":"page"},{"location":"highlevels/uncertainty_quantification/#MonteCarloMeasurements.jl:-Automated-Monte-Carlo-Error-Propagation","page":"Uncertainty Quantification","title":"MonteCarloMeasurements.jl: Automated Monte Carlo Error Propagation","text":"","category":"section"},{"location":"highlevels/uncertainty_quantification/","page":"Uncertainty Quantification","title":"Uncertainty Quantification","text":"MonteCarloMeasurements.jl is a library for automating the uncertainty quantification of equation solution using Monte Carlo methods. It defines number types which sample from an input distribution to receive a representative set of parameters that propagate through the solver to calculate a representative set of possible solutions. Note that Monte Carlo techniques can be expensive but are exact, in the sense that as the number of sample points increases to infinity it will compute a correct approximation of the output uncertainty.","category":"page"},{"location":"highlevels/uncertainty_quantification/#ProbNumDiffEq.jl:-Probabilistic-Numerics-Based-Differential-Equation-Solvers","page":"Uncertainty Quantification","title":"ProbNumDiffEq.jl: Probabilistic Numerics Based Differential Equation Solvers","text":"","category":"section"},{"location":"highlevels/uncertainty_quantification/","page":"Uncertainty Quantification","title":"Uncertainty Quantification","text":"ProbNumDiffEq.jl is a a set of probabilistic numerical ODE solvers which compute the solution of a differential equation along with a posterior distribution to estimate its numerical approximation error. Thus these specialized integrators compute an uncertainty output similar to the ProbInts technique of DiffEqUncertainty, but use specialized integration techniques in order to do it much faster for specific kinds of equations.","category":"page"},{"location":"highlevels/uncertainty_quantification/#TaylorIntegration.jl:-Taylor-Series-Integration-for-Rigorous-Numerical-Bounds","page":"Uncertainty Quantification","title":"TaylorIntegration.jl: Taylor Series Integration for Rigorous Numerical Bounds","text":"","category":"section"},{"location":"highlevels/uncertainty_quantification/","page":"Uncertainty Quantification","title":"Uncertainty Quantification","text":"TaylorIntegration.jl is a library for Taylor series integrators which has special functionality for computing the interval bound of possible solutions with respect to numerical approximation error.","category":"page"},{"location":"highlevels/uncertainty_quantification/#IntervalArithmetic.jl:-Rigorous-Numerical-Intervals","page":"Uncertainty Quantification","title":"IntervalArithmetic.jl: Rigorous Numerical Intervals","text":"","category":"section"},{"location":"highlevels/uncertainty_quantification/","page":"Uncertainty Quantification","title":"Uncertainty Quantification","text":"IntervalArithmetic.jl is a library for performing interval arithmetic calculations on arbitrary Julia code. Interval arithmetic computes rigorous computations with respect to finite-precision floating point arithmetic, i.e. its intervals are guaranteed to include the true solution. However, interval arithmetic intervals can grow at exponential rates in many problems, thus being unsuitable for analyses in many equation solver contexts.","category":"page"},{"location":"getting_started/installation/#installation","page":"Installing SciML Software","title":"Installing SciML Software","text":"","category":"section"},{"location":"getting_started/installation/#Step-1:-Install-Julia","page":"Installing SciML Software","title":"Step 1: Install Julia","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"Download Julia using this website.","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"note: Note\nSome Linux distributions do weird and incorrect things with Julia installations! Please install Julia using the binaries provided by the official JuliaLang website!","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"To ensure that you have installed Julia correctly, open it up and type versioninfo() in the REPL. It should look like the following:","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"(Image: )","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"(with the CPU/OS/etc. details matching your computer!)","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"If you got stuck in this installation process, ask for help on the Julia Discourse or in the Julia Zulip chatrooms","category":"page"},{"location":"getting_started/installation/#Optional-Step-1.5:-Get-VS-Code-Setup-with-the-Julia-Extension","page":"Installing SciML Software","title":"Optional Step 1.5: Get VS Code Setup with the Julia Extension","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"You can run SciML with Julia in any development environment you please, but our recommended environment is VS Code. For more information on using Julia with VS Code, check out the Julia VS Code Extension website. Let's install it!","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"First download VS Code from the official website.","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"Next, open Visual Studio Code and click Extensions.","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"(Image: )","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"Then, search for \"Julia\" in the search bar on the top of the extension tab, click on the \"Julia\" extension, and click the install button on the tab that opens up.","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"(Image: )","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"To make sure your installation is correct, try running some code. Open a new file by either going to the top left navigation bar File |> New Text File, or hitting Ctrl+n. Name your new file test.jl (important: the Julia VS Code functionality only turns on when using a .jl file!). Next, type 1+1 and hit Ctrl+Enter. A Julia REPL should pop up and the result 2 should be displayed. Your environment should look something like this:","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"(Image: )","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"For more help on using the VS Code editor with Julia, check out the VS Code in Julia documentation. Useful keyboard commands can be found here.","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"Once again, if you got stuck in this installation process, ask for help on the Julia Discourse or in the Julia Zulip chatrooms","category":"page"},{"location":"getting_started/installation/#Step-2:-Install-a-SciML-Package","page":"Installing SciML Software","title":"Step 2: Install a SciML Package","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"SciML is over 130 Julia packages. That's too much stuff to give someone in a single download! Thus instead, the SciML organization divides its functionality into composable modules that can be mixed and matched as required. Installing SciML ecosystem functionality is equivalent to installation such packages.","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"For example, do you need the differential equation solver? Then install DifferentialEquations via the command:","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"using Pkg; Pkg.add(\"DifferentialEquations\")","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"in the Julia REPL. Or, for a more robust REPL experience, hit the ] command to make the blue pkg> REPL environment start, and type in add DifferentialEquations. The package REPL environment will have nice extras like auto-complete that will be useful in the future. This command should run an installation sequence and precompile all of the packages (precompile = \"run a bunch of performance optimizations!\"). Don't be surprised if this installation process takes ~10 minutes on older computers. During the installation, it should look like this:","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"(Image: )","category":"page"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"And that's it!","category":"page"},{"location":"getting_started/installation/#How-do-I-test-that-my-installed-correctly?","page":"Installing SciML Software","title":"How do I test that my installed correctly?","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installing SciML Software","title":"Installing SciML Software","text":"The best way is to build and run your first simulation!","category":"page"},{"location":"highlevels/plots_visualization/#SciML-Supported-Plotting-and-Visualization-Libraries","page":"SciML-Supported Plotting and Visualization Libraries","title":"SciML-Supported Plotting and Visualization Libraries","text":"","category":"section"},{"location":"highlevels/plots_visualization/","page":"SciML-Supported Plotting and Visualization Libraries","title":"SciML-Supported Plotting and Visualization Libraries","text":"The following libraries are the plotting and visualization libraries which are supported and co-developed by the SciML developers. Other libraries may be used, though these are the libraries used in the tutorials and which have special hooks to ensure ergonomic usage with SciML tooling.","category":"page"},{"location":"highlevels/plots_visualization/#Plots.jl","page":"SciML-Supported Plotting and Visualization Libraries","title":"Plots.jl","text":"","category":"section"},{"location":"highlevels/plots_visualization/","page":"SciML-Supported Plotting and Visualization Libraries","title":"SciML-Supported Plotting and Visualization Libraries","text":"Plots.jl is the current standard plotting system for the SciML ecosystem. SciML types attempt to include plot recipes for as many types as possible, allowing for automatic visualization with the Plots.jl system. All current tutorials and documentation default to using Plots.jl.","category":"page"},{"location":"highlevels/plots_visualization/#Makie.jl","page":"SciML-Supported Plotting and Visualization Libraries","title":"Makie.jl","text":"","category":"section"},{"location":"highlevels/plots_visualization/","page":"SciML-Supported Plotting and Visualization Libraries","title":"SciML-Supported Plotting and Visualization Libraries","text":"Makie.jl is a high-performance interactive plotting system for the Julia programming language. It's planned to be the default plotting system used by the SciML organization in the near future.","category":"page"},{"location":"highlevels/model_libraries_and_importers/#Model-Libraries-and-Importers","page":"Model Libraries and Importers","title":"Model Libraries and Importers","text":"","category":"section"},{"location":"highlevels/model_libraries_and_importers/","page":"Model Libraries and Importers","title":"Model Libraries and Importers","text":"Models are passed on from generation to generation. Many models are not built by scratch but have a legacy of the known physics, biology, and chemistry embedded into them. Julia's SciML offers a range of pre-built modeling tools, from acausal components to reuse to direct imports from common file formats.","category":"page"},{"location":"highlevels/model_libraries_and_importers/#ModelingToolkitStandardLibrary.jl:-A-Standard-Library-for-ModelingToolkit","page":"Model Libraries and Importers","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"","category":"section"},{"location":"highlevels/model_libraries_and_importers/","page":"Model Libraries and Importers","title":"Model Libraries and Importers","text":"Given the composable nature of acausal modeling systems, it's helpful to not have to define every component from scratch and instead build off a common base of standard components. ModelingToolkitStandardLibrary.jl is that library. It provides components for standard models to start building everything from circuits and engines to robots.","category":"page"},{"location":"highlevels/model_libraries_and_importers/","page":"Model Libraries and Importers","title":"Model Libraries and Importers","text":"(Image: )","category":"page"},{"location":"highlevels/model_libraries_and_importers/#DiffEqCallbacks.jl:-Pre-Made-Callbacks-for-DifferentialEquations.jl","page":"Model Libraries and Importers","title":"DiffEqCallbacks.jl: Pre-Made Callbacks for DifferentialEquations.jl","text":"","category":"section"},{"location":"highlevels/model_libraries_and_importers/","page":"Model Libraries and Importers","title":"Model Libraries and Importers","text":"DiffEqCallbacks.jl has many event handling and callback definitions which allow for quickly building up complex differential equation models. It includes:","category":"page"},{"location":"highlevels/model_libraries_and_importers/","page":"Model Libraries and Importers","title":"Model Libraries and Importers","text":"Callbacks for specialized output and saving procedures\nCallbacks for enforcing domain constraints, positivity, and manifolds\nTimed callbacks for periodic dosing, preseting of tstops, and more\nCallbacks for determining and terminating at steady state\nCallbacks for controlling stepsizes and enforcing CFL conditions\nCallbacks for quantifying uncertainty with respect to numerical errors","category":"page"},{"location":"highlevels/model_libraries_and_importers/#SBMLToolkit.jl:-SBML-Import","page":"Model Libraries and Importers","title":"SBMLToolkit.jl: SBML Import","text":"","category":"section"},{"location":"highlevels/model_libraries_and_importers/","page":"Model Libraries and Importers","title":"Model Libraries and Importers","text":"SBMLToolkit.jl is a library for reading SBML files into the standard formats for Catalyst.jl and ModelingToolkit.jl. There are more than one thousand biological models available in the the BioModels Repository.","category":"page"},{"location":"highlevels/model_libraries_and_importers/#CellMLToolkit.jl:-CellML-Import","page":"Model Libraries and Importers","title":"CellMLToolkit.jl: CellML Import","text":"","category":"section"},{"location":"highlevels/model_libraries_and_importers/","page":"Model Libraries and Importers","title":"Model Libraries and Importers","text":"CellMLToolkit.jl is a library for reading CellML files into the standard formats for ModelingToolkit.jl. There are several hundred biological models available in the the CellML Model Repository.","category":"page"},{"location":"highlevels/model_libraries_and_importers/#ReactionNetworkImporters.jl:-BioNetGen-Import","page":"Model Libraries and Importers","title":"ReactionNetworkImporters.jl: BioNetGen Import","text":"","category":"section"},{"location":"highlevels/model_libraries_and_importers/","page":"Model Libraries and Importers","title":"Model Libraries and Importers","text":"ReactionNetworkImporters.jl is a library for reading BioNetGen .net files and various stoichiometry matrix representations  into the standard formats for Catalyst.jl and ModelingToolkit.jl.","category":"page"},{"location":"comparisons/cppfortran/#cppfortran","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Getting Started with Julia's SciML for the C++/Fortran User","text":"","category":"section"},{"location":"comparisons/cppfortran/","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Getting Started with Julia's SciML for the C++/Fortran User","text":"You don't need help if you're a Fortran guru. I'm just kidding, you're not a Lisp developer. If you're coming from C++ or Fortran, you may be familiar with similar high-performance computing environments to SciML are PETSc, Trilinos, or Sundials. The following are some points to help the transition.","category":"page"},{"location":"comparisons/cppfortran/#Why-SciML?-High-Level-Workflow-Reasons","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Why SciML? High-Level Workflow Reasons","text":"","category":"section"},{"location":"comparisons/cppfortran/","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Getting Started with Julia's SciML for the C++/Fortran User","text":"If you're coming from \"hardcore\" C++/Fortran computing environments, some things to check out with Julia's SciML are:","category":"page"},{"location":"comparisons/cppfortran/","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Getting Started with Julia's SciML for the C++/Fortran User","text":"Interactivity - use the interactive REPL to easily investigate numerical details.\nMetaprogramming performance tools - tools like LoopVectorization.jl can be used to generate faster code than even some of the most hand-optimized C++/Fortran code. Current benchmarks show this SIMD-optimized Julia code outperforming OpenBLAS and MKL BLAS implementations in many performance regimes.\nSymbolic modeling languages - writing models by hand can leave a lot of performance on the table. Using high-level modeling tools like ModelingToolkit can automate symbolic simplifications which improve the stability and performance of numerical solvers. On complex models, even the best handwritten C++/Fortran code is orders of magnitude behind the code that symbolic tearing algorithms can achieve!\nComposable Library Components - In C++/Fortran environments, every package feels like a silo. Arrays made for PETSc cannot easily be used in Trilinos, and converting Sundials NVector outputs to DataFrames for post-simulation data processing is a process itself. The Julia SciML environment embraces interoperability. Don't wait for SciML to do it: by using generic coding with JIT compilation these connections create new optimized code on the fly and allow for a more expansive feature set than can ever be documented. Take new high-precision number types from a package and stick them into a nonlinear solver. Take a package for Intel GPU arrays and stick it into the differential equation solver to use specialized hardware acceleration.\nWrappers to the Libraries You Know and Trust - Moving to SciML does not have to be a quick transition. SciML has extensive wrappers to many widely-used classical solver environments such as SUNDIALS and Hairer's classic Fortran ODE solvers (dopri5, dop853, etc.). Using these wrapped solvers is painless and can be swapped in for the Julia versions with one line of code. This gives you a way to incrementally adopt new features/methods while retaining the older pieces you know and trust.\nDon't Start from Scratch - SciML builds on the extensive Base library of Julia and thus grows and improves with every update to the language. With hundreds of monthly contributors to SciML and hundreds of monthly contributors to Julia, SciML is one of the most actively developed open source scientific computing ecosystems out there!\nEasier High-Performance and Parallel Computing - With Julia's ecosystem, CUDA will automatically install of the required binaries and cu(A)*cu(B) is then all that's required to GPU-accelerate large-scale linear algebra. MPI is easy to install and use. Distributed computing through password-less SSH. Multithreading is automatic and baked into a lot of libraries, with a specialized algorithm to ensure hierarchical usage does not oversubscribe threads. Basically, libraries give you a lot of parallelism for free, and doing the rest is a piece of cake.\nMix Scientific Computing with Machine Learning - Want to automate the discovery of missing physical laws using neural networks embedded in differentiable simulations? Julia's SciML is the ecosystem with the tooling to integrate machine learning into the traditional high-performance scientific computing domains, from multiphysics simulations to partial differential equations.","category":"page"},{"location":"comparisons/cppfortran/","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Getting Started with Julia's SciML for the C++/Fortran User","text":"In this plot, Sundials/Hairer in purple/red represent C++/Fortrans most commonly used solvers:","category":"page"},{"location":"comparisons/cppfortran/","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Getting Started with Julia's SciML for the C++/Fortran User","text":"(Image: )","category":"page"},{"location":"comparisons/cppfortran/#Why-SciML?-Some-Technical-Details","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Why SciML? Some Technical Details","text":"","category":"section"},{"location":"comparisons/cppfortran/","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Getting Started with Julia's SciML for the C++/Fortran User","text":"Let's face the facts, in the open benchmarks the pure-Julia solvers tend to outperform the classic \"best\" C++ and Fortran solvers in almost every example (with a few notable exceptions). But why?","category":"page"},{"location":"comparisons/cppfortran/","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Getting Started with Julia's SciML for the C++/Fortran User","text":"The answer is two-fold: Julia is as fast as C++/Fortran, and the algorithms are what matter.","category":"page"},{"location":"comparisons/cppfortran/#Julia-is-as-Fast-as-C/Fortran","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Julia is as Fast as C++/Fortran","text":"","category":"section"},{"location":"comparisons/cppfortran/","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Getting Started with Julia's SciML for the C++/Fortran User","text":"While Julia code looks high level like Python or MATLAB, its performance is on par with C++ and Fortran. At a technical level, when Julia code is type-stable, i.e. that the types that are returned from a function are deducible at compile-time from the types that go into a function, then Julia can optimize it as much as C++ or Fortran by automatically devirtualizing all dynamic behavior and compile-time optimizing the quasi-static code. This is not an empirical statement, it's a provable type-theoretic result. The resulting compiler used on the resulting quasi-static representation is LLVM, the same optimizing compiler used by clang and LFortran.","category":"page"},{"location":"comparisons/cppfortran/","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Getting Started with Julia's SciML for the C++/Fortran User","text":"For more details on how Julia code is optimized and how to optimize your own Julia code, check out this chapter from the SciML Book.","category":"page"},{"location":"comparisons/cppfortran/#SciML's-Julia-Algorithms-Have-Performance-Advantages-in-Many-Common-Regimes","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"SciML's Julia Algorithms Have Performance Advantages in Many Common Regimes","text":"","category":"section"},{"location":"comparisons/cppfortran/","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Getting Started with Julia's SciML for the C++/Fortran User","text":"There are many ways which Julia's algorithms achieve performance advantages. Some facts to highlight include:","category":"page"},{"location":"comparisons/cppfortran/","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Getting Started with Julia's SciML for the C++/Fortran User","text":"Julia is at the forefront of numerical methods research in many domains. This is highlighted in the differential equation solver comparisons where the Julia solvers were the first to incorporate \"newer\" optimized Runge-Kutta tableaus, around half a decade before other software. Since then, the literature has only continued to evolve, and only Julia's SciML keeps up. At this point, many of the publication's first implementation is in OrdinaryDiffEq.jl with benchmark results run on the SciML Open Benchmarking platform!\nJulia does not take low-level mathematical functions for granted. The common openlibm implementation of mathematical functions used in many open source projects is maintained by the Julia and SciML developers! However, in modern Julia, every function from   log to ^ has been reimplemented in the Julia standard library to improve numerical correctness and performance. For example, Pumas, the nonlinear mixed effects estimation system built on SciML and used by Moderna for the vaccine trials notes in its paper that approximations to such math libraries itself gave a 2x performance improvement in even the most simple non-stiff ODE solvers over matching Fortran implementations. Pure Julia linear algebra tooling, like RecursiveFactorization.jl for LU-factorization, outperforms common LU-factorization implementations used in open-source projects like OpenBLAS by around 5x! This should not be surprising though, given that OpenBLAS was a prior MIT Julia Lab project!\nCompilers are limited on the transformations that they can perform because they do not have high-level context-dependent mathematical knowledge. Julia's SciML makes extensive use of customized symbolic-based compiler transformations to improve performance with context-based code optimizations. Things like sparsity patterns are automatically deduced from code and optimized on. Nonlinear equations are symbolically-torn, changing large nonlinear systems into sequential solving of much smaller systems and benefiting from an O(n^3) cost reduction. These can be orders of magnitude cost reductions which come for free, and unless you know every trick in the book it will be hard to match SciML's performance!\nPervasive automatic differentiation mixed with compiler tricks wins battles. Many high-performance libraries in C++ and Fortran cannot assume that all of its code is compatible with automatic differentiation, and thus many internal performance tricks are not applied. For example ForwardDiff.jl's chunk seeding allows for a single call to f to generate multiple columns of a Jacobian. When mixed with sparse coloring tools, entire Jacobians can be constructed with just a few f calls. Studies in applications have shown this greatly outperforms finite differencing, especially when Julia's implicit multithreading is used.","category":"page"},{"location":"comparisons/cppfortran/#Let's-Dig-Deep-Into-One-Case:-Adjoints-of-ODEs-for-Solving-Inverse-Problems","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Let's Dig Deep Into One Case: Adjoints of ODEs for Solving Inverse Problems","text":"","category":"section"},{"location":"comparisons/cppfortran/","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Getting Started with Julia's SciML for the C++/Fortran User","text":"To really highlight how JIT compilation and automatic differentiation integration can change algorithms, let's look at the problem of differentiating an ODE solver. As is derived an discussed in detail at a seminar with the American Statistical Association, there are many ways to implement well-known \"adjoint\" methods which are required for performance. Each has different stability and performance trade-offs, and Julia's SciML is the only system to systemically offer all of the trade-off options. In many cases, using analytical adjoints of a solver is not advised due to performance reasons, with the trade-off described in detail here. Likewise, even when analytical adjoints are used, it turns out that for general nonlinear equations there is a trick which uses automatic differentiation in the construction of the analytical adjoint to improve its performance. As demonstrated in this publication, this can lead to about 2-3 orders of magnitude performance improvements. These AD-enhanced adjoints are showcased as the seeding methods in this plot:","category":"page"},{"location":"comparisons/cppfortran/","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Getting Started with Julia's SciML for the C++/Fortran User","text":"(Image: )","category":"page"},{"location":"comparisons/cppfortran/","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Getting Started with Julia's SciML for the C++/Fortran User","text":"Unless one directly defines special \"vjp\" functions, this is how the Julia SciML methods achieve orders of magnitude performance advantages over CVODES's adjoints and PETSC's TS-adjoint.","category":"page"},{"location":"comparisons/cppfortran/","page":"Getting Started with Julia's SciML for the C++/Fortran User","title":"Getting Started with Julia's SciML for the C++/Fortran User","text":"Moral of the story, even there are many reasons to use automatic differentiation of a solver, and even if an analytical adjoint rule is used for some specific performance reason, that analytical expression can often times be accelerated by orders of magnitude itself by embedding some form of automatic differentiation into it. This is just one algorithm of many which are optimized in this fashion.","category":"page"},{"location":"getting_started/first_optimization/#first_opt","page":"Solve your first optimization problem","title":"Solve your first optimization problem","text":"","category":"section"},{"location":"getting_started/first_optimization/","page":"Solve your first optimization problem","title":"Solve your first optimization problem","text":"Numerical optimization is the process of finding some numerical values that minimize some equation. ","category":"page"},{"location":"getting_started/first_optimization/","page":"Solve your first optimization problem","title":"Solve your first optimization problem","text":"How much fuel should you put into an airplane to have the minimum weight that  can go to its destination?\nWhat parameters should I choose for my simulation so that it minimizes the distance of its predictions from my experimental data?\n","category":"page"},{"location":"getting_started/first_optimization/","page":"Solve your first optimization problem","title":"Solve your first optimization problem","text":"All of these are examples of problems solved by numerical optimization.  Let's solve our first optimization problem!","category":"page"},{"location":"getting_started/first_optimization/#Problem-Setup","page":"Solve your first optimization problem","title":"Problem Setup","text":"","category":"section"},{"location":"getting_started/first_optimization/","page":"Solve your first optimization problem","title":"Solve your first optimization problem","text":"First, what are we solving? Let's take a look at the Rosenbrock equation:","category":"page"},{"location":"getting_started/first_optimization/","page":"Solve your first optimization problem","title":"Solve your first optimization problem","text":"L(up) = (p_1 - u_1)^2 + p_2 * (u_2 - u_1)^2","category":"page"},{"location":"getting_started/first_optimization/","page":"Solve your first optimization problem","title":"Solve your first optimization problem","text":"What we want to do is find the  values of u_1 and u_2 such that L  achieves its minimum value possible. We will do this under a few constraints:  we want to find this optima within some bounded domain, i.e. u_i in -11.  This should be done with the parameter values p_1 = 10 and p_2 = 100.0.  What shouldu = [u_1,u_2]` be to achieve this goal? Let's dive in!","category":"page"},{"location":"getting_started/first_optimization/","page":"Solve your first optimization problem","title":"Solve your first optimization problem","text":"note: Note\nThe upper and lower bounds are optional for the solver! If your problem does not need to have such bounds, just leave off the parts with lb and ub!","category":"page"},{"location":"getting_started/first_optimization/#Copy-Pastable-Code","page":"Solve your first optimization problem","title":"Copy-Pastable Code","text":"","category":"section"},{"location":"getting_started/first_optimization/","page":"Solve your first optimization problem","title":"Solve your first optimization problem","text":"# Import the package \nusing Optimization, OptimizationNLopt\n\n# Define the problem to optimize\nL(u,p) =  (p[1] - u[1])^2 + p[2] * (u[2] - u[1]^2)^2\nu0 = zeros(2)\np  = [1.0,100.0]\nprob = OptimizationProblem(L, u0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\n\n# Solve the optimization problem\nsol = solve(prob,NLopt.LD_LBFGS())\n\n# Analyze the solution\n@show sol.u, L(sol.u,p)","category":"page"},{"location":"getting_started/first_optimization/#Step-1:-Import-the-packages","page":"Solve your first optimization problem","title":"Step 1: Import the packages","text":"","category":"section"},{"location":"getting_started/first_optimization/","page":"Solve your first optimization problem","title":"Solve your first optimization problem","text":"using Optimization, OptimizationNLopt","category":"page"},{"location":"getting_started/first_optimization/#Step-2:-Define-the-Optimization-Problem","page":"Solve your first optimization problem","title":"Step 2: Define the Optimization Problem","text":"","category":"section"},{"location":"getting_started/first_optimization/","page":"Solve your first optimization problem","title":"Solve your first optimization problem","text":"# Define the problem to optimize\nL(u,p) = (p[1] - u[1])^2 + p[2] * (u[2] - u[1]^2)^2","category":"page"},{"location":"getting_started/first_optimization/","page":"Solve your first optimization problem","title":"Solve your first optimization problem","text":"u0 = zeros(2)\np  = [1.0,100.0]\nprob = OptimizationProblem(L, u0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])","category":"page"},{"location":"getting_started/first_optimization/#Step-3:-Solve-the-Optimization-Problem","page":"Solve your first optimization problem","title":"Step 3: Solve the Optimization Problem","text":"","category":"section"},{"location":"getting_started/first_optimization/","page":"Solve your first optimization problem","title":"Solve your first optimization problem","text":"# Solve the optimization problem\nsol = solve(prob,NLopt.LD_LBFGS())","category":"page"},{"location":"getting_started/first_optimization/#Step-4:-Analyze-the-Solution","page":"Solve your first optimization problem","title":"Step 4: Analyze the Solution","text":"","category":"section"},{"location":"getting_started/first_optimization/","page":"Solve your first optimization problem","title":"Solve your first optimization problem","text":"# Analyze the solution\n@show sol.u, L(sol.u,p)","category":"page"},{"location":"comparisons/python/#python","page":"Getting Started with Julia's SciML for the Python User","title":"Getting Started with Julia's SciML for the Python User","text":"","category":"section"},{"location":"comparisons/python/","page":"Getting Started with Julia's SciML for the Python User","title":"Getting Started with Julia's SciML for the Python User","text":"If you're an Python user who has looked into Julia, you're probably wondering what is the equivalent to SciPy is. And you found it: it's the SciML ecosystem! To a Python developer, SciML is SciPy, but with the high-performance GPU etc. capabilities of PyTorch, and neural network capabilities, all baked right in. With SciML, there is no \"separate world\" of machine learning sublanguages: there is just one cohesive package ecosystem.","category":"page"},{"location":"comparisons/python/#Why-SciML?-High-Level-Workflow-Reasons","page":"Getting Started with Julia's SciML for the Python User","title":"Why SciML? High-Level Workflow Reasons","text":"","category":"section"},{"location":"comparisons/python/","page":"Getting Started with Julia's SciML for the Python User","title":"Getting Started with Julia's SciML for the Python User","text":"Performance - The key reason people are moving from SciPy to Julia's SciML in droves is performance. Even simple ODE solvers are much faster!, demonstrating orders of magnitude performance improvements for differential equations, nonlinear solving, optimization, and more. And the performance advantages continue to grow as more complex algorithms are required.\nPackage Management and Versioning - Julia's package manager takes care of dependency management, testing, and continuous delivery in order to make the installation and maintenance process smoother. For package users, this means it's easier to get packages with complex functionality in your hands.\nComposable Library Components - In R environments, every package feels like a silo. Functions made for one file exchange library cannot easily compose with another. SciML's generic coding with JIT compilation these connections create new optimized code on the fly and allow for a more expansive feature set than can ever be documented. Take new high-precision number types from a package and stick them into a nonlinear solver. Take a package for Intel GPU arrays and stick it into the differential equation solver to use specialized hardware acceleration.\nEasier High-Performance and Parallel Computing - With Julia's ecosystem, CUDA will automatically install of the required binaries and cu(A)*cu(B) is then all that's required to GPU-accelerate large-scale linear algebra. MPI is easy to install and use. Distributed computing through password-less SSH. Multithreading is automatic and baked into a lot of libraries, with a specialized algorithm to ensure hierarchical usage does not oversubscribe threads. Basically, libraries give you a lot of parallelism for free, and doing the rest is a piece of cake.\nMix Scientific Computing with Machine Learning - Want to automate the discovery of missing physical laws using neural networks embedded in differentiable simulations? Julia's SciML is the ecosystem with the tooling to integrate machine learning into the traditional high-performance scientific computing domains, from multiphysics simulations to partial differential equations.","category":"page"},{"location":"comparisons/python/","page":"Getting Started with Julia's SciML for the Python User","title":"Getting Started with Julia's SciML for the Python User","text":"In this plot, SciPy in yellow represents Python's most commonly used solvers:","category":"page"},{"location":"comparisons/python/","page":"Getting Started with Julia's SciML for the Python User","title":"Getting Started with Julia's SciML for the Python User","text":"(Image: )","category":"page"},{"location":"comparisons/python/#Need-Help-Translating-from-Python-to-Julia?","page":"Getting Started with Julia's SciML for the Python User","title":"Need Help Translating from Python to Julia?","text":"","category":"section"},{"location":"comparisons/python/","page":"Getting Started with Julia's SciML for the Python User","title":"Getting Started with Julia's SciML for the Python User","text":"The following resources can be particularly helpful when adopting Julia for SciML for the first time:","category":"page"},{"location":"comparisons/python/","page":"Getting Started with Julia's SciML for the Python User","title":"Getting Started with Julia's SciML for the Python User","text":"The Julia Manual's Noteworthy Differences from Python page\nDouble check your results with SciPyDiffEq.jl (automatically converts and runs ODE definitions with SciPy's solvers)\nUse PyCall.jl to more incrementally move code to Julia.","category":"page"},{"location":"comparisons/python/#Python-to-Julia-SciML-Functionality-Translations","page":"Getting Started with Julia's SciML for the Python User","title":"Python to Julia SciML Functionality Translations","text":"","category":"section"},{"location":"comparisons/python/","page":"Getting Started with Julia's SciML for the Python User","title":"Getting Started with Julia's SciML for the Python User","text":"The following chart will help you get quickly acquainted with Julia's SciML Tools:","category":"page"},{"location":"comparisons/python/","page":"Getting Started with Julia's SciML for the Python User","title":"Getting Started with Julia's SciML for the Python User","text":"Workflow Element SciML-Supported Julia packages\nmatplotlib Plots, Makie\nscipy.special SpecialFunctions\nscipy.linalg.solve LinearSolve\nscipy.integrate Integrals\nscipy.optimize Optimization\nscipy.optimize.fsolve NonlinearSolve\nscipy.interpolate DataInterpolations\nscipy.fft FFTW\nscipy.linalg Julia's Built-In Linear Algebra\nscipy.sparse SparseArrays, ARPACK\nodeint/solve_ivp DifferentialEquations\nscipy.integrate.solve_bvp Boundary-value problem\nPyTorch Flux, Lux\ngillespy2 Catalyst, JumpProcesses\nscipy.optimize.approx_fprime FiniteDiff\nautograd ForwardDiff*, Enzyme*, DiffEqSensitivity\nStan Turing\nsympy Symbolics","category":"page"},{"location":"comparisons/python/#Why-is-Differentiable-Programming-Important-for-Scientific-Computing?","page":"Getting Started with Julia's SciML for the Python User","title":"Why is Differentiable Programming Important for Scientific Computing?","text":"","category":"section"},{"location":"comparisons/python/","page":"Getting Started with Julia's SciML for the Python User","title":"Getting Started with Julia's SciML for the Python User","text":"Check out this blog post that goes into detail on how training neural networks in tandem with simulation improves performance by orders of magnitude. But can't you use analytical adjoint definitions? You can, but there are tricks to mix automatic differentiation into the adjoint definitions for a few orders of magnitude improvement too, as explained in this blog post.","category":"page"},{"location":"comparisons/python/","page":"Getting Started with Julia's SciML for the Python User","title":"Getting Started with Julia's SciML for the Python User","text":"This facts, along with many others, compose to algorithmic improvements with the implementation improvements, which leads to orders of magnitude improvements!","category":"page"},{"location":"getting_started/first_simulation/#first_sim","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"","category":"section"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"In this tutorial we will build and run our first simulation with SciML!","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"note: Note\nThis tutorial assumes that you have already installed Julia on your system. If you have not done so already, please follow the installation tutorial first.","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"To build our simulation, we will use the ModelingToolkit system for modeling and simulation. ModelingToolkit is a bit higher level than directly defining code for a differential equation system: it's a symbolic system that will automatically simplify our models, optimize our code, and generate compelling visualizations. Sounds neat? Let's dig in.","category":"page"},{"location":"getting_started/first_simulation/#Our-Problem:-Simulate-the-Lotka-Volterra-Predator-Prey-Dynamics","page":"Build and run your first simulation with Julia's SciML","title":"Our Problem: Simulate the Lotka-Volterra Predator-Prey Dynamics","text":"","category":"section"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"The dynamics of our system are given by the Lotka-Volterra dynamical system: Let x(t) be the number of rabbits in the environment and y(t) be the number of wolves. The equation that defines the evolution of the species is given as follows:","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"beginalign\nfracdxdt = alpha x - beta x y\nfracdydt = -gamma y + delta x y\nendalign","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"where alpha beta gamma delta are parameters. Starting from equal numbers of rabbits and wolves, x(0) = 1 and y(0) = 1, we want to simulate this system from time t_0 = 0 to t_f = 10. Luckily, a local guide provided our with some parameters that seem to match the system! These are alpha = 15, beta = 10, gamma = 30, delta = 10. How many rabbits and wolves will there be 10 months from now? And if z = x + y, i.e. the total number of animals at a given time, can we visualize this total number of animals at each time?","category":"page"},{"location":"getting_started/first_simulation/#Solution-as-Copy-Pastable-Code","page":"Build and run your first simulation with Julia's SciML","title":"Solution as Copy-Pastable Code","text":"","category":"section"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"using ModelingToolkit, DifferentialEquations, Plots\n\n# Define our state variables: state(t) = initial condition\n@variables t x(t)=1 y(t)=1 z(t)=2\n\n# Define our parameters\n@parameters α=1.5 β=1.0 γ=3.0 δ=1.0\n\n# Define our differential: takes the derivative with respect to `t`\nD = Differential(t)\n\n# Define the differential equations\neqs = [\n    D(x) ~ α*x - β*x*y\n    D(y) ~ -γ*y + δ*x*y\n    z ~ x + y\n]\n\n# Bring these pieces together into an ODESystem with independent variable t\n@named sys = ODESystem(eqs,t)\n\n# Symbolically Simplify the System\nsimpsys = structural_simplify(sys)\n\n# Convert from a symbolic to a numerical problem to simulate\ntspan = (0.0,10.0)\nprob = ODEProblem(simpsys, [], tspan)\n\n# Solve the ODE\nsol = solve(prob)\n\n# Plot the solution\np1 = plot(sol,title = \"Rabbits vs Wolves\")\np2 = plot(sol,idxs=z,title = \"Total Animals\")\n\nplot(p1,p2,layout=(2,1))","category":"page"},{"location":"getting_started/first_simulation/#Step-by-Step-Solution","page":"Build and run your first simulation with Julia's SciML","title":"Step by Step Solution","text":"","category":"section"},{"location":"getting_started/first_simulation/#Step-1:-Install-and-Import-the-Required-Packages","page":"Build and run your first simulation with Julia's SciML","title":"Step 1: Install and Import the Required Packages","text":"","category":"section"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"To do this tutorial we will need a few components:","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"ModelingToolkit.jl, our modeling environment\nDifferentialEquations.jl, the differential equation solvers\nPlots.jl, our visualization tool","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"To start, let's add these packages as demonstrated in the installation tutorial:","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"]add ModelingToolkit DifferentialEquations Plots","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"Now we're ready. Let's load in these packages:","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"using ModelingToolkit, DifferentialEquations, Plots","category":"page"},{"location":"getting_started/first_simulation/#Step-2:-Define-our-ODE-Equations","page":"Build and run your first simulation with Julia's SciML","title":"Step 2: Define our ODE Equations","text":"","category":"section"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"Now let's define our ODEs. We use the ModelingToolkit.@variabes statement to declare our variables. We have the independent variable time t, and then define our 3 state variables:","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"# Define our state variables: state(t) = initial condition\n@variables t x(t)=1 y(t)=1 z(t)=2","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"Notice here that we use the form state = default, where on the right-hand side the default value of a state is interpreted to be its initial condition. This is then done similarly for parameters, where the default value is now the parameter value:","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"# Define our parameters\n@parameters α=1.5 β=1.0 γ=3.0 δ=1.0","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"Next we define our set of differential equations. We need to first tell it what to differentiate with respect to, here the independent variable t, do define the Differential operator D. Then once we have the operator, we apply that into the equations.","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"note: Note\nNote that in ModelingToolkit and Symbolics, ~ is used for equation equality. This is separate from = which is the \"assignment operator\" in the Julia programming language. For example, x = x + 1 is a valid assignment in a programming language, and it is invalid for that to represent \"equality\", which is the reason why a separate operator is used!","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"# Define our differential: takes the derivative with respect to `t`\nD = Differential(t)\n\n# Define the differential equations\neqs = [\n    D(x) ~ α*x - β*x*y\n    D(y) ~ -γ*y + δ*x*y\n    z ~ x + y\n]","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"Notice that in the display it will automatically generate LaTeX. If one is interested in generating this LaTeX locally, one can simply do:","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"using Latexify # add the package first\nlatexify(eqs)","category":"page"},{"location":"getting_started/first_simulation/#Step-3:-Define-the-ODEProblem","page":"Build and run your first simulation with Julia's SciML","title":"Step 3: Define the ODEProblem","text":"","category":"section"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"Now we bring these pieces together. In ModelingToolkit, we can bring these pieces together to represent an ODESystem with the following:","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"# Bring these pieces together into an ODESystem with independent variable t\n@named sys = ODESystem(eqs,t)","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"Next, we want to simplify this into a standard ODE system. Notice that in our equations we have an algebraic equation z ~ x + y. This is not a differential equation but an algebraic equation, and thus we call this set of equations a Differential-Algebraic Equation (DAE). The symbolic system of ModelingToolkit can eliminate such equations to return simpler forms to numerically approximate. Let's tell it to simplify the system using structural_simplify:","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"# Symbolically Simplify the System\nsimpsys = structural_simplify(sys)","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"Notice that what is returned is another ODESystem, but now with the simplified set of equations. z has been turned into an \"observable\", i.e. a state that is not computed but can be constructed on-demand. This is one of the ways that SciML reaches its speed: you can have 100,000 equations, but solve only 1,000 to then automatically reconstruct the full set. Here, it's just 3 equations to 2, but as models get more complex the symbolic system will find ever more clever interactions!","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"Now that we have simplified our system, let's turn it into a numerical problem to approximate. This is done with the ODEProblem constructor, that transforms it from a symbolic ModelingToolkit representation to a numerical DifferentialEquations representation. We need to tell it the numerical details now:","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"Whether to override any of the default values for the initial conditions and parameters.\nWhat is the initial time point.\nHow long to integrate it for.","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"In this case, we will use the default values for all our variables, so we will pass a blank override []. If for example we did want to change the initial condition of x to 2.0 and α to 4.0, we would do [x => 2.0, α => 4.0]. Then secondly we pass a tuple for the time span, (0.0,10.0) meaning start at 0.0 and end at 10.0. This looks like:","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"# Convert from a symbolic to a numerical problem to simulate\ntspan = (0.0,10.0)\nprob = ODEProblem(simpsys, [], tspan)","category":"page"},{"location":"getting_started/first_simulation/#Step-4:-Solve-the-ODE-System","page":"Build and run your first simulation with Julia's SciML","title":"Step 4: Solve the ODE System","text":"","category":"section"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"Now we solve the ODE system. Julia's SciML solvers have a defaulting system that can automatically determine an appropriate solver for a given system, so we can just tell it to solve:","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"# Solve the ODE\nsol = solve(prob)","category":"page"},{"location":"getting_started/first_simulation/#Step-5:-Visualize-the-Solution","page":"Build and run your first simulation with Julia's SciML","title":"Step 5: Visualize the Solution","text":"","category":"section"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"Now let's visualize the solution! Notice that our solution only has two states. If we recall, the simplified system only has two states: z was symbolically eliminated. We can access any of the values, even the eliminated values, using the symbolic variable as the index. For example:","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"sol[z]","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"returns the time series of the observable z at time points corresponding to sol.t. We can use this with the automated plotting functionality. First let's create a plot of x and y over time using plot(sol) which will plot all of the states. Then next, we will explicitly tell it to make a plot with the index being z, i.e. idxs=z.","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"note: Note\nNote that one can pass an array of indices as well, so idxs=[x,y,z] would make a plot with all three lines together!","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"# Plot the solution\np1 = plot(sol,title = \"Rabbits vs Wolves\")\np2 = plot(sol,idxs=z,title = \"Total Animals\")","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"Finally, let's make a plot where we merge these two plot elements. To do so, we can take our two plot objects, p1 and p2, and make a plot with both of them. Then we tell Plots to do a layout of (2,1), or 2 rows and 1 columns. Let's see what happens when we bring these together:","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"plot(p1,p2,layout=(2,1))","category":"page"},{"location":"getting_started/first_simulation/","page":"Build and run your first simulation with Julia's SciML","title":"Build and run your first simulation with Julia's SciML","text":"And tada, we have a full analysis of our ecosystem!","category":"page"},{"location":"highlevels/numerical_utilities/#SciML-Numerical-Utility-Libraries","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"","category":"section"},{"location":"highlevels/numerical_utilities/#ExponentialUtilities.jl:-Faster-Matrix-Exponentials","page":"SciML Numerical Utility Libraries","title":"ExponentialUtilities.jl: Faster Matrix Exponentials","text":"","category":"section"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"ExponentialUtilities.jl is a library for efficient computation of matrix exponentials. While Julia has a built-in exp(A) method, ExponentialUtilities.jl offers many features around this to improve performance in scientific contexts, including:","category":"page"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"Faster methods for (non-allocating) matrix exponentials via exponential!\nMethods for computing matrix exponential that are generic to number types and arrays (i.e. GPUs)\nMethods for computing arnoldi iterations on Krylov subspaces\nDirect computation of exp(t*A)*v, i.e. exponentiation of a matrix times a vector, without computing the matrix exponential\nDirect computation of ϕ_m(t*A)*v operations, where ϕ_0(z) = exp(z) and ϕ_(k+1)(z) = (ϕ_k(z) - 1) / z","category":"page"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"ExponentialUtilities.jl includes complex adaptive time stepping techniques such as KIOPS in order to perform these calculations in a fast and numerically-stable way.","category":"page"},{"location":"highlevels/numerical_utilities/#QuasiMonteCarlo.jl:-Fast-Quasi-Random-Number-Generation","page":"SciML Numerical Utility Libraries","title":"QuasiMonteCarlo.jl: Fast Quasi-Random Number Generation","text":"","category":"section"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"QuasiMonteCarlo.jl is a library for fast generation of ow discrepancy Quasi-Monte Carlo samples, using methods like:","category":"page"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"GridSample(dx) where the grid is given by lb:dx[i]:ub in the ith direction.\nUniformSample for uniformly distributed random numbers.\nSobolSample for the Sobol sequence.\nLatinHypercubeSample for a Latin Hypercube.\nLatticeRuleSample for a randomly-shifted rank-1 lattice rule.\nLowDiscrepancySample(base) where base[i] is the base in the ith direction.\nGoldenSample for a Golden Ratio sequence.\nKroneckerSample(alpha, s0) for a Kronecker sequence, where alpha is an length-d vector of irrational numbers (often sqrt(d)) and s0 is a length-d seed vector (often 0).\nSectionSample(x0, sampler) where sampler is any sampler above and x0 is a vector of either NaN for a free dimension or some scalar for a constrained dimension.","category":"page"},{"location":"highlevels/numerical_utilities/#PoissonRandom.jl:-Fast-Poisson-Random-Number-Generation","page":"SciML Numerical Utility Libraries","title":"PoissonRandom.jl: Fast Poisson Random Number Generation","text":"","category":"section"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"PoissonRandom.jl is just fast Poisson random number generation for Poisson processes, like chemical master equations.","category":"page"},{"location":"highlevels/numerical_utilities/#PreallocationTools.jl:-Write-Non-Allocating-Code-Easier","page":"SciML Numerical Utility Libraries","title":"PreallocationTools.jl: Write Non-Allocating Code Easier","text":"","category":"section"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"PreallocationTools.jl is a library of tools for writing non-allocating code that interacts well with advanced features like automatic differentiation and symbolics.","category":"page"},{"location":"highlevels/numerical_utilities/#RuntimeGeneratedFunctions.jl:-Efficient-Staged-Programming-in-Julia","page":"SciML Numerical Utility Libraries","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Programming in Julia","text":"","category":"section"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"RuntimeGeneratedFunctions.jl allows for staged programming in Julia, compiling functions at runtime with full optimizations. This is used by many libraries such as ModelingToolkit.jl to allow for runtime code generation for improved performance.","category":"page"},{"location":"highlevels/numerical_utilities/#EllipsisNotation.jl:-Implementation-of-Ellipsis-Array-Slicing","page":"SciML Numerical Utility Libraries","title":"EllipsisNotation.jl: Implementation of Ellipsis Array Slicing","text":"","category":"section"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"EllipsisNotation.jl defines the ellipsis array slicing notation for Julia. It uses .. as a catch all for \"all dimensions\", allow for indexing like [..,1] to mean \"[:,:,:,1]` on four dimensional arrays, in a way that is generic to the number of dimensions in the underlying array.","category":"page"},{"location":"highlevels/numerical_utilities/#Third-Party-Libraries-to-Note","page":"SciML Numerical Utility Libraries","title":"Third Party Libraries to Note","text":"","category":"section"},{"location":"highlevels/numerical_utilities/#Distributions.jl:-Representations-of-Probability-Distributions","page":"SciML Numerical Utility Libraries","title":"Distributions.jl: Representations of Probability Distributions","text":"","category":"section"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"Distributions.jl is a library for defining distributions in Julia. It's used all throughout the SciML libraries for specifications of probability distributions.","category":"page"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"note: Note\nFor full compatibility with automatic differentiation, see DistributionsAD.jl","category":"page"},{"location":"highlevels/numerical_utilities/#FFTW.jl:-Fastest-Fourier-Transformation-in-the-West","page":"SciML Numerical Utility Libraries","title":"FFTW.jl: Fastest Fourier Transformation in the West","text":"","category":"section"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"FFTW.jl is the preferred library for fast Fourier Transformations on the CPU.","category":"page"},{"location":"highlevels/numerical_utilities/#SpecialFunctions.jl:-Implementations-of-Mathematical-Special-Functions","page":"SciML Numerical Utility Libraries","title":"SpecialFunctions.jl: Implementations of Mathematical Special Functions","text":"","category":"section"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"SpecialFunctions.jl is a library of implementations of special functions, like Bessel functions and error functions (erf). This library is compatible with automatic differentiation.","category":"page"},{"location":"highlevels/numerical_utilities/#LoopVectorization.jl:-Automated-Loop-Accelerator","page":"SciML Numerical Utility Libraries","title":"LoopVectorization.jl: Automated Loop Accelerator","text":"","category":"section"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"LoopVectorization.jl is a library which provides the @turbo and @tturbo macros for accelerating the computation of loops. This can be used to accelerating the model functions sent to the equation solvers, for example, accelerating handwritten PDE discretizations.","category":"page"},{"location":"highlevels/numerical_utilities/#Polyester.jl:-Cheap-Threads","page":"SciML Numerical Utility Libraries","title":"Polyester.jl: Cheap Threads","text":"","category":"section"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"Polyester.jl is a cheaper version of threads for Julia which use a set pool of threads for lower overhead. Note that Polyester does not compose with the standard Julia composable threading infrastructure, and thus one must take care to not compose two levels of Polyester as this will oversubscribe the computation and lead to performance degradation. Many SciML solvers have options to use Polyseter for threading to achieve the top performance.","category":"page"},{"location":"highlevels/numerical_utilities/#Tullio.jl:-Fast-Tensor-Calculations-and-Einstein-Notation","page":"SciML Numerical Utility Libraries","title":"Tullio.jl: Fast Tensor Calculations and Einstein Notation","text":"","category":"section"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"Tullio.jl is a library for fast tensor calculations with Einstein notation. It allows for defining operations which are compatible with automatic differentiation, GPUs, and more.","category":"page"},{"location":"highlevels/numerical_utilities/#ParallelStencil.jl:-High-Level-Code-for-Parallelized-Stencil-Computations","page":"SciML Numerical Utility Libraries","title":"ParallelStencil.jl: High-Level Code for Parallelized Stencil Computations","text":"","category":"section"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"ParallelStencil.jl is a library for writing high level code forparallelized stencil computations. It is compatible with SciML equation solvers and is thus a good way to generate GPU and distributed parallel model code.","category":"page"},{"location":"highlevels/numerical_utilities/#DataInterpolations.jl:-One-Dimensional-Interpolations","page":"SciML Numerical Utility Libraries","title":"DataInterpolations.jl: One-Dimensional Interpolations","text":"","category":"section"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"DataInterpolations.jl is a library of one-dimensional interpolation schemes which are composable with automatic differentiation and the SciML ecosystem. It includes direct interpolation methods and regression techniques for handling noisy data. Its methods include:","category":"page"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"ConstantInterpolation(u,t) - A piecewise constant interpolation.\nLinearInterpolation(u,t) - A linear interpolation.\nQuadraticInterpolation(u,t) - A quadratic interpolation.\nLagrangeInterpolation(u,t,n) - A Lagrange interpolation of order n.\nQuadraticSpline(u,t) - A quadratic spline interpolation.\nCubicSpline(u,t) - A cubic spline interpolation.\nBSplineInterpolation(u,t,d,pVec,knotVec) - An interpolation B-spline. This is a B-spline which hits each of the data points. The argument choices are: \t- d - degree of B-spline \t- pVec - Symbol to Parameters Vector, pVec = :Uniform for uniform spaced parameters and     pVec = :ArcLen for parameters generated by chord length method. \t- knotVec - Symbol to Knot Vector, knotVec = :Uniform for uniform knot vector,     knotVec = :Average for average spaced knot vector.\nBSplineApprox(u,t,d,h,pVec,knotVec) - A regression B-spline which smooths the fitting curve. The argument choices are the same as the BSplineInterpolation, with the additional parameter h<length(t) which is the number of control points to use, with smaller h indicating more smoothing.\nCurvefit(u,t,m,p,alg) - An interpolation which is done by fitting a user-given functional form m(t,p) where p is the vector of parameters. The user's input p is a an initial value for a least-square fitting, alg is the algorithm choice to use for optimize the cost function (sum of squared deviations) via Optim.jl and optimal ps are used in the interpolation.","category":"page"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"These interpolations match the SciML interfaces and have direct support for packages like ModelingToolkit.jl.","category":"page"},{"location":"highlevels/numerical_utilities/#Julia-Utilities","page":"SciML Numerical Utility Libraries","title":"Julia Utilities","text":"","category":"section"},{"location":"highlevels/numerical_utilities/#StaticCompiler.jl","page":"SciML Numerical Utility Libraries","title":"StaticCompiler.jl","text":"","category":"section"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"StaticCompiler.jl is a package for generating static binaries from Julia code. It only supports a subset of Julia, so not all equation solver algorithms are compatible with StaticCompiler.jl.","category":"page"},{"location":"highlevels/numerical_utilities/#PackageCompiler.jl","page":"SciML Numerical Utility Libraries","title":"PackageCompiler.jl","text":"","category":"section"},{"location":"highlevels/numerical_utilities/","page":"SciML Numerical Utility Libraries","title":"SciML Numerical Utility Libraries","text":"PackageCompiler.jl is a package for generating shared libraries from Julia code. It the entirety of Julia by bundling a system image with the Julia runtime, thus it builds complete binaries that can hold all of the functionality of SciML. It can also be used to generate new system images to decrease startup times and remove JIT-compilation from SciML usage.","category":"page"},{"location":"highlevels/developer_documentation/#Developer-Documentation","page":"Developer Documentation","title":"Developer Documentation","text":"","category":"section"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"For uniformity and clarity, the SciML Open Source Software Organization has many well-defined rules and practices for its development. However, we stress one important principle:","category":"page"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"Do not be deterred from contributing if you think you do not know everything. No one knows everything. These rules and styles are designed for iterative contributions. Open pull requests and contribute what you can with what you know, and the maintainers will help you learn and do the rest!","category":"page"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"If you need any help contributing, please feel welcome joining our community channels.","category":"page"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"The diffeq-bridged and sciml-bridged channels in the Julia Zulip Chat\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"We welcome everybody.","category":"page"},{"location":"highlevels/developer_documentation/#Getting-Started-With-Contributing-to-SciML","page":"Developer Documentation","title":"Getting Started With Contributing to SciML","text":"","category":"section"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"To get started contributing to SciML, check out the following resources:","category":"page"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"Developing Julia Packages\nGetting Started with Julia (for Experienced Programmers)","category":"page"},{"location":"highlevels/developer_documentation/#SciMLStyle:-The-SciML-Style-Guide-for-Julia","page":"Developer Documentation","title":"SciMLStyle: The SciML Style Guide for Julia","text":"","category":"section"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"(Image: SciML Code Style)","category":"page"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"This is a style guide for how to program in Julia for SciML contributions. It describes everything one needs to know, from preferred naming schemes of functions to fundamental dogmas for designing traits. We stress that this style guide is meant to be comprehensive for the sake of designing automatic formatters and teaching desired rules, but complete knowledge and adherence to the style guide is not required for contributions!","category":"page"},{"location":"highlevels/developer_documentation/#COLPRAC:-Contributor's-Guide-on-Collaborative-Practices-for-Community-Packages","page":"Developer Documentation","title":"COLPRAC: Contributor's Guide on Collaborative Practices for Community Packages","text":"","category":"section"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"(Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)","category":"page"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"What are the rules for when PRs should be merged? What are the rules for whether to tag a major, minor, or patch release? All of these development rules are defined in COLPRAC.","category":"page"},{"location":"highlevels/developer_documentation/#DiffEq-Developer-Documentation","page":"Developer Documentation","title":"DiffEq Developer Documentation","text":"","category":"section"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"There are many solver libraries which share similar internals, such as OrdinaryDiffEq.jl, StochasticDiffEq.jl, and DelayDiffEq.jl. This section of the documentation describes the internal systems of these packages and how they are used to quickly write efficient solvers.","category":"page"},{"location":"highlevels/developer_documentation/#Third-Party-Libraries-to-Note","page":"Developer Documentation","title":"Third Party Libraries to Note","text":"","category":"section"},{"location":"highlevels/developer_documentation/#Documenter.jl","page":"Developer Documentation","title":"Documenter.jl","text":"","category":"section"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"Documenter.jl is the documentation generation library that the SciML organization uses, and thus its documentation is the documentation of the documentation.","category":"page"},{"location":"highlevels/developer_documentation/#JuliaFormatter.jl","page":"Developer Documentation","title":"JuliaFormatter.jl","text":"","category":"section"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"JuliaFormatter.jl is the formatter used by the SciML organization to enforce the SciML Style. Setting style = \"sciml\" in a .JuliaFormatter.toml file of a repo and using the standard FormatCheck.yml as part of continuous integration makes JuliaFormatter check for SciML Style compliance on pull requests.","category":"page"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"To run JuliaFormatter in a SciML repository, do:","category":"page"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"using JuliaFomatter, DevedPackage\nJuliaFormatter.format(pkgdir(DevedPackage))","category":"page"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"which will reformat the code according to the SciML Style.","category":"page"},{"location":"highlevels/developer_documentation/#Github-Actions-Continuous-Integrations","page":"Developer Documentation","title":"Github Actions Continuous Integrations","text":"","category":"section"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"The SciML Organization uses continuous integration testing to always ensure tests are passing when merging pull requests. The organization uses the Github Actions supplied by Julia Actions to accomplish this. Common continuous integration scripts are:","category":"page"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"CI.yml, the standard CI script\nDownstream.yml, used to specify packages for downstream testing. This will make packages which depend on the current package also be tested to ensure that \"non-breaking changes\" do not actually break other packages.\nDocumentation.yml, used to run the documentation automatic generation with Documenter.jl\nFormatCheck.yml, used to check JuliaFormatter SciML Style compliance","category":"page"},{"location":"highlevels/developer_documentation/#CompatHelper","page":"Developer Documentation","title":"CompatHelper","text":"","category":"section"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"CompatHelper is used to automatically create pull requests whenever a dependent package is upper bounded. The results of CompatHelper PRs should be checked to ensure that the latest version of the dependencies are grabbed for the test process. After successful CompatHelper PRs, i.e. if the increase of the upper bound did not cause a break to the tests, a new version tag should follow. It is setup by adding the CompatHelper.yml Github action.","category":"page"},{"location":"highlevels/developer_documentation/#TagBot","page":"Developer Documentation","title":"TagBot","text":"","category":"section"},{"location":"highlevels/developer_documentation/","page":"Developer Documentation","title":"Developer Documentation","text":"TagBot automatically creates tags in the Github repository whenever a package is registered to the Julia General repository. It is setup by adding the TagBot.yml Github action.","category":"page"},{"location":"highlevels/modeling_languages/#Modeling-Languages","page":"Modeling Languages","title":"Modeling Languages","text":"","category":"section"},{"location":"highlevels/modeling_languages/","page":"Modeling Languages","title":"Modeling Languages","text":"While in theory one can build perfect code for all models from scratch, in practice many scientists and engineers need or want some help! The SciML modeling tools provide a higher level interface over the equation solvers which helps the translation from good models to good simulations in a way that abstracts away the mathematical and computational details without giving up performance.","category":"page"},{"location":"highlevels/modeling_languages/#ModelingToolkit.jl:-Acausal-Symbolic-Modeling","page":"Modeling Languages","title":"ModelingToolkit.jl: Acausal Symbolic Modeling","text":"","category":"section"},{"location":"highlevels/modeling_languages/","page":"Modeling Languages","title":"Modeling Languages","text":"Acausal modeling is an extension of causal modeling that is more composable and allows for more code reuse. Build a model of an electric engine, then build a model of a battery, and now declare connections by stating \"the voltage at the engine equals the voltage at the connector of the battery\", and generate the composed model. The tool for this is ModelingToolkit.jl. ModelingToolkit.jl is a sophisticated symbolic modeling library which allows for specifying these types of large-scale differential equation models in a simple way, abstracting away the computational details. However, its symbolic analysis allows for generating much more performant code for differential-algebraic equations than most users could ever write by hand, with its structural_simplify automatically correcting the model to improve parallelism, numerical stability, and automatically remove variables which it can show are redundant.","category":"page"},{"location":"highlevels/modeling_languages/","page":"Modeling Languages","title":"Modeling Languages","text":"ModelingToolkit.jl is the base of the SciML symbolic modeling ecosystem, defining the AbstractSystem types, such as ODESystem, SDESystem, OptimizationSystem, PDESystem, and more, which are then used by all of the other modeling tools. As such, when using other modeling tools like Catalyst.jl, the reference for all of the things that can be done with the symbolic representation is simply ModelingToolkit.jl.","category":"page"},{"location":"highlevels/modeling_languages/#Catalyst.jl:-Chemical-Reaction-Networks-(CRN),-Systems-Biology,-and-Quantitative-Systems-Pharmacology-(QSP)-Modeling","page":"Modeling Languages","title":"Catalyst.jl: Chemical Reaction Networks (CRN), Systems Biology, and Quantitative Systems Pharmacology (QSP) Modeling","text":"","category":"section"},{"location":"highlevels/modeling_languages/","page":"Modeling Languages","title":"Modeling Languages","text":"Catalyst.jl is a modeling interface for efficient simulation of chemical master equation representations chemical reaction networks and other systems models. It uses a highly intuitive chemical reaction syntax interface which generates all of the extra functionality necessary for the fastest use with DiffEqJump.jl and DifferentialEquations.jl. Its ReactionSystem type is a programmable extension of the ModelingToolkit AbstractSystem interface, meaning that complex reaction systems can be generated through code.","category":"page"},{"location":"highlevels/modeling_languages/","page":"Modeling Languages","title":"Modeling Languages","text":"For an overview of the library, see Modeling Biochemical Systems with Catalyst.jl - Samuel Isaacson","category":"page"},{"location":"highlevels/modeling_languages/#NBodySimulator.jl:-A-differentiable-simulator-for-N-body-problems,-including-astrophysical-and-molecular-dynamics","page":"Modeling Languages","title":"NBodySimulator.jl: A differentiable simulator for N-body problems, including astrophysical and molecular dynamics","text":"","category":"section"},{"location":"highlevels/modeling_languages/","page":"Modeling Languages","title":"Modeling Languages","text":"NBodySimulator.jl is differentiable simulator for N-body problems, including astrophysical and molecular dynamics. It uses the DifferentialEquations.jl solvers, allowing for one to choose between a large variety of symplectic integration schemes. It implements many of the thermostats required for doing standard molecular dynamics approximations.","category":"page"},{"location":"highlevels/modeling_languages/#DiffEqFinancial.jl:-Financial-models-for-use-in-the-DifferentialEquations-ecosystem","page":"Modeling Languages","title":"DiffEqFinancial.jl: Financial models for use in the DifferentialEquations ecosystem","text":"","category":"section"},{"location":"highlevels/modeling_languages/","page":"Modeling Languages","title":"Modeling Languages","text":"The goal of DiffEqFinancial.jl is to be a feature-complete set of solvers for the types of problems found in libraries like QuantLib, such as the Heston process or the Black-Scholes model.","category":"page"},{"location":"highlevels/modeling_languages/#ParameterizedFunctions.jl:-Simple-Differential-Equation-Definitions-Made-Easy","page":"Modeling Languages","title":"ParameterizedFunctions.jl: Simple Differential Equation Definitions Made Easy","text":"","category":"section"},{"location":"highlevels/modeling_languages/","page":"Modeling Languages","title":"Modeling Languages","text":"(Image: )","category":"page"},{"location":"highlevels/modeling_languages/","page":"Modeling Languages","title":"Modeling Languages","text":"This image that went viral is actually runnable code from ParameterizedFunctions.jl. Define equations and models using a very simple high level syntax and let the code generation tools build symbolic fast Jacobian, gradient, etc. functions for you.","category":"page"},{"location":"highlevels/modeling_languages/#Third-Party-Tools-of-Note","page":"Modeling Languages","title":"Third Party Tools of Note","text":"","category":"section"},{"location":"highlevels/modeling_languages/#MomentClosure.jl:-Automated-Generation-of-Moment-Closure-Equations","page":"Modeling Languages","title":"MomentClosure.jl: Automated Generation of Moment Closure Equations","text":"","category":"section"},{"location":"highlevels/modeling_languages/","page":"Modeling Languages","title":"Modeling Languages","text":"MomentClosure.jl is a library for generating the moment closure equations for a given chemical master equation or stochastic differential equation. Thus instead of solving a stochastic model thousands of times to find the mean and variance, this library can generate the deterministic equations for how the mean and variance evolve in order to be solved in a single run. MomentClosure.jl uses Catalyst ReactionSystem and ModelingToolkit SDESystem types as the input for its symbolic generation processes.","category":"page"},{"location":"highlevels/modeling_languages/#Agents.jl:-Agent-Based-Modeling-Framework-in-Julia","page":"Modeling Languages","title":"Agents.jl: Agent-Based Modeling Framework in Julia","text":"","category":"section"},{"location":"highlevels/modeling_languages/","page":"Modeling Languages","title":"Modeling Languages","text":"If one wants to do agent-based modeling in Julia, Agents.jl is the go-to library. It's fast and flexible, making it a solid foundation for any agent-based model.","category":"page"},{"location":"highlevels/modeling_languages/#Unitful.jl:-A-Julia-package-for-physical-units","page":"Modeling Languages","title":"Unitful.jl: A Julia package for physical units","text":"","category":"section"},{"location":"highlevels/modeling_languages/","page":"Modeling Languages","title":"Modeling Languages","text":"Supports not only SI units but also any other unit system. Unitful.jl has minimal run-time penalty of units. Includes facilities for dimensional analysis, and integrates easily with the usual mathematical operations and collections that are defined in Julia.","category":"page"},{"location":"highlevels/modeling_languages/#ReactionMechanismSimulator.jl:-Simulation-and-Analysis-of-Large-Chemical-Reaction-Systems","page":"Modeling Languages","title":"ReactionMechanismSimulator.jl: Simulation and Analysis of Large Chemical Reaction Systems","text":"","category":"section"},{"location":"highlevels/modeling_languages/","page":"Modeling Languages","title":"Modeling Languages","text":"ReactionMechanismSimulator.jl is a tool for simulating and analyzing large chemical reaction mechanisms. It interfaces with the ReactionMechanismGenerator suite for automatically constructing reaction pathways from chemical components to quickly build realistic models of chemical systems.","category":"page"},{"location":"highlevels/modeling_languages/#FiniteStateProjection.jl:-Direct-Solution-of-Chemical-Master-Equations","page":"Modeling Languages","title":"FiniteStateProjection.jl: Direct Solution of Chemical Master Equations","text":"","category":"section"},{"location":"highlevels/modeling_languages/","page":"Modeling Languages","title":"Modeling Languages","text":"FiniteStateProjection.jl is a library for finite state projection direct solving of the chemical master equation. It automatically converts the Catalyst ReactionSystem definitions into ModelingToolkit ODESystem representations for the evolution of probability distributions to allow for directly solving the weak form of the stochastic model.","category":"page"},{"location":"highlevels/modeling_languages/#AlgebraicPetri.jl:-Applied-Category-Theory-of-Modeling","page":"Modeling Languages","title":"AlgebraicPetri.jl: Applied Category Theory of Modeling","text":"","category":"section"},{"location":"highlevels/modeling_languages/","page":"Modeling Languages","title":"Modeling Languages","text":"AlgebraicPetri.jl is a library for automating the intuitive generation of dynamical models using a Category theory based approach.","category":"page"},{"location":"highlevels/modeling_languages/#QuantumOptics.jl:-Simulating-quantum-systems.","page":"Modeling Languages","title":"QuantumOptics.jl: Simulating quantum systems.","text":"","category":"section"},{"location":"highlevels/modeling_languages/","page":"Modeling Languages","title":"Modeling Languages","text":"QuantumOptics.jl makes it easy to simulate various kinds of quantum systems. It is inspired by the Quantum Optics Toolbox for MATLAB and the Python framework QuTiP.","category":"page"},{"location":"highlevels/learning_resources/#Curated-Learning,-Teaching,-and-Training-Resources","page":"Curated Learning, Teaching, and Training Resources","title":"Curated Learning, Teaching, and Training Resources","text":"","category":"section"},{"location":"highlevels/learning_resources/","page":"Curated Learning, Teaching, and Training Resources","title":"Curated Learning, Teaching, and Training Resources","text":"While the SciML documentation is made to be comprehensive, there will always be good alternative resources. The purpose of this section of the documentation is to highlight the alternative resources which can be helpful for learning how to use the SciML Open Source Software libraries.","category":"page"},{"location":"highlevels/learning_resources/#SciMLTutorials","page":"Curated Learning, Teaching, and Training Resources","title":"SciMLTutorials","text":"","category":"section"},{"location":"highlevels/learning_resources/","page":"Curated Learning, Teaching, and Training Resources","title":"Curated Learning, Teaching, and Training Resources","text":"SciMLTutorials.jl is an extended set of tutorials for the SciML open source software organization. It contains many complete workflow examples on large-scale problems that may be too large or complex for normal documentation, but good materials for users to learn from.","category":"page"},{"location":"highlevels/learning_resources/#JuliaCon-and-SciMLCon-Videos","page":"Curated Learning, Teaching, and Training Resources","title":"JuliaCon and SciMLCon Videos","text":"","category":"section"},{"location":"highlevels/learning_resources/","page":"Curated Learning, Teaching, and Training Resources","title":"Curated Learning, Teaching, and Training Resources","text":"Many tutorials and introductions to packages have been taught through previous JuliaCon/SciMLCon workshops and talks. The following is a curated list of such training videos:","category":"page"},{"location":"highlevels/learning_resources/","page":"Curated Learning, Teaching, and Training Resources","title":"Curated Learning, Teaching, and Training Resources","text":"Intro to solving differential equations in Julia\nJuliaCon 2020 | Doing Scientific Machine Learning (SciML) With Julia\nSimulating Big Models in Julia with ModelingToolkit | Workshop | JuliaCon 2021\nStructural Identifiability Tools in Julia: A Tutorial | Ilia Ilmer | SciMLCon 2022\nJuliaCon 2018 | Solving Partial Differential Equations with Julia | Chris Rackauckas","category":"page"},{"location":"highlevels/learning_resources/#SciML-Book:-Parallel-Computing-and-Scientific-Machine-Learning-(SciML):-Methods-and-Applications","page":"Curated Learning, Teaching, and Training Resources","title":"SciML Book: Parallel Computing and Scientific Machine Learning (SciML): Methods and Applications","text":"","category":"section"},{"location":"highlevels/learning_resources/","page":"Curated Learning, Teaching, and Training Resources","title":"Curated Learning, Teaching, and Training Resources","text":"The book Parallel Computing and Scientific Machine Learning (SciML): Methods and Applications is a compilation of the lecture notes from the MIT Course 18.337J/6.338J: Parallel Computing and Scientific Machine Learning. It contains a walkthrough of many of the methods implemented in the SciML libraries, as well as how to understand much of the functionality at a deeper level. This course was intended for MIT graduate students in engineering, computer science, and mathematics and thus may have a high prerequisite requirement than many other resources.","category":"page"},{"location":"highlevels/learning_resources/#sir-julia:-Various-implementations-of-the-classical-SIR-model-in-Julia","page":"Curated Learning, Teaching, and Training Resources","title":"sir-julia: Various implementations of the classical SIR model in Julia","text":"","category":"section"},{"location":"highlevels/learning_resources/","page":"Curated Learning, Teaching, and Training Resources","title":"Curated Learning, Teaching, and Training Resources","text":"For those who like to learn by example, the repository sir-julia is a great resource! It showcases how to use the SciML libraries in many different ways to simulate different variations of the classic SIR epidemic model.","category":"page"},{"location":"highlevels/learning_resources/#Other-Books-Featuring-SciML","page":"Curated Learning, Teaching, and Training Resources","title":"Other Books Featuring SciML","text":"","category":"section"},{"location":"highlevels/learning_resources/","page":"Curated Learning, Teaching, and Training Resources","title":"Curated Learning, Teaching, and Training Resources","text":"Nonlinear Dynamics: A Concise Introduction Interlaced with Code\nNumerical Methods for Scientific Computing: The Definitive Manual for Math Geeks\nFundamentals of Numerical Computation\nStatistics with Julia\nStatistical Rethinking with Julia\nThe Koopman Operator in Systems and Control\n\"All simulations have been performed in Julia, with additional Julia packages: LinearAlgebra.jl, Random.jl, Plots.jl, Lasso.jl, DifferentialEquations.jl\"","category":"page"},{"location":"highlevels/implicit_layers/#Implicit-Layer-Deep-Learning","page":"Implicit Layer Deep Learning","title":"Implicit Layer Deep Learning","text":"","category":"section"},{"location":"highlevels/implicit_layers/","page":"Implicit Layer Deep Learning","title":"Implicit Layer Deep Learning","text":"Implicit layer deep learning is a field which uses implicit rules, such as differential equations and nonlinear solvers, to define the layers of neural networks. This field has brought the potential to automatically optimize network depth and improve training performance. SciML's differentiable solver ecosystem is specifically designed to accommodate implicit layer methodologies, and provides libraries with pre-built layers for common methods.","category":"page"},{"location":"highlevels/implicit_layers/#DiffEqFlux.jl:-High-Level-Pre-Built-Architectures-for-Implicit-Deep-Learning","page":"Implicit Layer Deep Learning","title":"DiffEqFlux.jl: High Level Pre-Built Architectures for Implicit Deep Learning","text":"","category":"section"},{"location":"highlevels/implicit_layers/","page":"Implicit Layer Deep Learning","title":"Implicit Layer Deep Learning","text":"DiffEqFlux.jl is a library of pre-built architectures for implicit deep learning, including layer definitions for methods like:","category":"page"},{"location":"highlevels/implicit_layers/","page":"Implicit Layer Deep Learning","title":"Implicit Layer Deep Learning","text":"Neural Ordinary Differential Equations (Neural ODEs)\nCollocation-Based Neural ODEs (Neural ODEs without a solver, by far the fastest way!)\nMultiple Shooting Neural Ordinary Differential Equations\nNeural Stochastic Differential Equations (Neural SDEs)\nNeural Differential-Algebraic Equations (Neural DAEs)\nNeural Delay Differential Equations (Neural DDEs)\nAugmented Neural ODEs\nHamiltonian Neural Networks (with specialized second order and symplectic integrators)\nContinuous Normalizing Flows (CNF) and FFJORD","category":"page"},{"location":"highlevels/implicit_layers/#DeepEquilibriumNetworks.jl:-Deep-Equilibrium-Models-Made-Fast","page":"Implicit Layer Deep Learning","title":"DeepEquilibriumNetworks.jl: Deep Equilibrium Models Made Fast","text":"","category":"section"},{"location":"highlevels/implicit_layers/","page":"Implicit Layer Deep Learning","title":"Implicit Layer Deep Learning","text":"DeepEquilibriumNetworks.jl is a library of optimized layer implementations for Deep Equilibrium Models (DEQs). It uses special training techniques such as implicit-explicit regularization in order to accelerate the convergence over traditional implementations, all while using the optimized and flexible SciML libraries under the hood.","category":"page"},{"location":"getting_started/fit_simulation/#fit_simulation","page":"Fit a simulation to a dataset","title":"Fit a simulation to a dataset","text":"","category":"section"},{"location":"highlevels/partial_differential_equation_solvers/#Partial-Differential-Equations-(PDE)","page":"Partial Differential Equations (PDE)","title":"Partial Differential Equations (PDE)","text":"","category":"section"},{"location":"highlevels/partial_differential_equation_solvers/#NeuralPDE.jl:-Physics-Informed-Neural-Network-(PINN)-PDE-Solvers","page":"Partial Differential Equations (PDE)","title":"NeuralPDE.jl: Physics-Informed Neural Network (PINN) PDE Solvers","text":"","category":"section"},{"location":"highlevels/partial_differential_equation_solvers/","page":"Partial Differential Equations (PDE)","title":"Partial Differential Equations (PDE)","text":"NeuralPDE.jl is a partial differential equation solver library which uses physics-informed neural networks (PINNs) to solve the equations. It uses the ModelingToolkit.jl symbolic PDESystem as its input and can handle a wide variety of equation types, including systems of partial differential equations, partial differential-algebraic equations, and integro-differential equations. Its benefit is its flexibility, and it can be used to easily generate surrogate solutions over entire parameter ranges. However, its downside is solver speed: PINN solvers tend to be a lot slower than other methods for solving PDEs.","category":"page"},{"location":"highlevels/partial_differential_equation_solvers/#MethodOflines.jl:-Automated-Finite-Difference-Method-(FDM)","page":"Partial Differential Equations (PDE)","title":"MethodOflines.jl: Automated Finite Difference Method (FDM)","text":"","category":"section"},{"location":"highlevels/partial_differential_equation_solvers/","page":"Partial Differential Equations (PDE)","title":"Partial Differential Equations (PDE)","text":"MethodOflines.jl is a partial differential equation solver library which automates the discretization of PDEs via the finite difference method. It uses the ModelingToolkit.jl symbolic PDESystem as its input, and generates AbstractSystems and SciMLProblems whose numerical solution gives the solution to the PDE.","category":"page"},{"location":"highlevels/partial_differential_equation_solvers/#FEniCS.jl:-Wrappers-for-the-Finite-Element-Method-(FEM)","page":"Partial Differential Equations (PDE)","title":"FEniCS.jl: Wrappers for the Finite Element Method (FEM)","text":"","category":"section"},{"location":"highlevels/partial_differential_equation_solvers/","page":"Partial Differential Equations (PDE)","title":"Partial Differential Equations (PDE)","text":"FEniCS.jl is a wrapper for the popular FEniCS finite element method library.","category":"page"},{"location":"highlevels/partial_differential_equation_solvers/#HighDimPDE.jl:-High-dimensional-PDE-Solvers","page":"Partial Differential Equations (PDE)","title":"HighDimPDE.jl:  High-dimensional PDE Solvers","text":"","category":"section"},{"location":"highlevels/partial_differential_equation_solvers/","page":"Partial Differential Equations (PDE)","title":"Partial Differential Equations (PDE)","text":"HighDimPDE.jl is a partial differential equation solver library which implements algorithms that break down the curse of dimensionality to solve the equations. It implements deep-learning based and Picard-iteration based methods to approximately solve high-dimensional, nonlinear, non-local PDEs in up to 10,000 dimensions. Its cons are accuracy: high-dimensional solvers are stochastic, and might result in wrong solutions if the solver meta-parameters are not appropriate.","category":"page"},{"location":"highlevels/partial_differential_equation_solvers/#NeuralOperators.jl:-(Fourier)-Neural-Operators-and-DeepONets-for-PDE-Solving","page":"Partial Differential Equations (PDE)","title":"NeuralOperators.jl: (Fourier) Neural Operators and DeepONets for PDE Solving","text":"","category":"section"},{"location":"highlevels/partial_differential_equation_solvers/","page":"Partial Differential Equations (PDE)","title":"Partial Differential Equations (PDE)","text":"NeuralOperators.jl is a library for operator learning based PDE solvers. This includes techniques like:","category":"page"},{"location":"highlevels/partial_differential_equation_solvers/","page":"Partial Differential Equations (PDE)","title":"Partial Differential Equations (PDE)","text":"Fourier Neural Operators (FNO)\nDeep Operator Networks (DeepONets)\nMarkov Neural Operators (MNO)","category":"page"},{"location":"highlevels/partial_differential_equation_solvers/","page":"Partial Differential Equations (PDE)","title":"Partial Differential Equations (PDE)","text":"Currently its connection to PDE solving must be specified manually, though an interface for ModelingToolkit PDESystems is in progress.","category":"page"},{"location":"highlevels/partial_differential_equation_solvers/#DiffEqOperators.jl:-Operators-for-Finite-Difference-Method-(FDM)-Discretizations","page":"Partial Differential Equations (PDE)","title":"DiffEqOperators.jl: Operators for Finite Difference Method (FDM) Discretizations","text":"","category":"section"},{"location":"highlevels/partial_differential_equation_solvers/","page":"Partial Differential Equations (PDE)","title":"Partial Differential Equations (PDE)","text":"DiffEqOperators.jl is a library for defining finite difference operators to easily perform manual FDM semi-discretizations of partial differential equations. This library is fairly incomplete and most cases should receive better performance using MethodOflines.jl.","category":"page"},{"location":"highlevels/partial_differential_equation_solvers/#Third-Party-Libraries-to-Note","page":"Partial Differential Equations (PDE)","title":"Third Party Libraries to Note","text":"","category":"section"},{"location":"highlevels/partial_differential_equation_solvers/#ApproxFun.jl:-Automated-Spectral-Discretizations","page":"Partial Differential Equations (PDE)","title":"ApproxFun.jl: Automated Spectral Discretizations","text":"","category":"section"},{"location":"highlevels/partial_differential_equation_solvers/","page":"Partial Differential Equations (PDE)","title":"Partial Differential Equations (PDE)","text":"ApproxFun.jl is a package for approximating functions in basis sets. One particular use case is with spectral basis sets, such as Chebyshev functions and Fourier decompositions, making it easy to represent spectral and pseudospectral discretizations of partial differential equations as ordinary differential equations for the SciML equation solvers.","category":"page"},{"location":"highlevels/partial_differential_equation_solvers/#Gridap.jl:-Julia-Based-Tools-for-Finite-Element-Discretizations","page":"Partial Differential Equations (PDE)","title":"Gridap.jl: Julia-Based Tools for Finite Element Discretizations","text":"","category":"section"},{"location":"highlevels/partial_differential_equation_solvers/","page":"Partial Differential Equations (PDE)","title":"Partial Differential Equations (PDE)","text":"Gridap.jl is a package for grid-based approximation of partial differential equations, particularly notable for its use of conforming and nonconforming finite element (FEM) discretizations.","category":"page"},{"location":"highlevels/partial_differential_equation_solvers/#Trixi.jl:-Adaptive-High-Order-Numerical-Simulations-of-Hyperbolic-Equations","page":"Partial Differential Equations (PDE)","title":"Trixi.jl: Adaptive High-Order Numerical Simulations of Hyperbolic Equations","text":"","category":"section"},{"location":"highlevels/partial_differential_equation_solvers/","page":"Partial Differential Equations (PDE)","title":"Partial Differential Equations (PDE)","text":"Trixi.jl is a package for numerical simulation of hyperbolic conservation laws, i.e. a large set of hyperbolic partial differential equations, which interfaces and uses the SciML ordinary differential equation solvers.","category":"page"},{"location":"highlevels/partial_differential_equation_solvers/#VoronoiFVM.jl:-Tools-for-the-Voronoi-Finite-Volume-Discretizations","page":"Partial Differential Equations (PDE)","title":"VoronoiFVM.jl: Tools for the Voronoi Finite Volume Discretizations","text":"","category":"section"},{"location":"highlevels/partial_differential_equation_solvers/","page":"Partial Differential Equations (PDE)","title":"Partial Differential Equations (PDE)","text":"VoronoiFVM.jl is a library for generating FVM discretizations of systems of PDEs. It interfaces with many of the SciML equation solver libraries to allow for ease of discretization and flexibility in the solver choice.","category":"page"},{"location":"overview/#overview","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"","category":"section"},{"location":"overview/#SciML:-Combining-High-Performance-Scientific-Computing-and-Machine-Learning","page":"Detailed Overview of the SciML Software Ecosystem","title":"SciML: Combining High-Performance Scientific Computing and Machine Learning","text":"","category":"section"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"SciML is not standard machine learning, SciML is the combination of scientific computing techniques with machine learning. Thus the SciML organization is not an organization for machine learning libraries (see FluxML for machine learning in Julia), rather SciML is an organization dedicated to the development of scientific computing tools which work seamlessly in conjunction with next-generation machine learning workflows. This includes:","category":"page"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"High performance and accurate tools for standard scientific computing modeling and simulation\nCompatibility with differentiable programming and automatic differentiation\nTools for building complex multiscale models\nMethods for handling inverse problems, model calibration, controls, and Bayesian analysis\nSymbolic modeling tools for generating efficient code for numerical equation solvers\nMethods for automatic discovery of (bio)physical equations","category":"page"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"and much more. For an overview of the broad goals of the SciML organization, watch:","category":"page"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"The Use and Practice of Scientific Machine Learning\nState of SciML Scientific Machine Learning","category":"page"},{"location":"overview/#Overview-of-Computational-Science-in-Julia-with-SciML","page":"Detailed Overview of the SciML Software Ecosystem","title":"Overview of Computational Science in Julia with SciML","text":"","category":"section"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"Below is a simplification of the user-facing packages for use in scientific computing and SciML workflows.","category":"page"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"Workflow Element SciML-Supported Julia packages\nPlotting and Visualization Plots*, Makie*\nSparse matrix SparseArrays*\nInterpolation/approximation DataInterpolations*, ApproxFun*\nLinear system / least squares LinearSolve\nNonlinear system / rootfinding NonlinearSolve\nPolynomial roots Polynomials*\nIntegration Integrals\nNonlinear Optimization Optimization\nOther Optimization (linear, quadratic, convex, etc.) JuMP*\nInitial-value problem DifferentialEquations\nBoundary-value problem DifferentialEquations\nContinuous-Time Markov Chains (Poisson Jumps), Jump Diffusions JumpProcesses\nFinite differences FiniteDifferences*, FiniteDiff*\nAutomatic Differentiation ForwardDiff*, Enzyme*, DiffEqSensitivity\nBayesian Modeling Turing*\nDeep Learning Flux*\nAcausal Modeling / DAEs ModelingToolkit\nChemical Reaction Networks Catalyst\nSymbolic Computing Symbolics\nFast Fourier Transform FFTW*","category":"page"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"Partial Differential Equation Discretizations Associated Julia packages\nFinite Differences MethodOfLines\nDiscontinuous Galerkin Trixi*\nFinite Element Gridap*\nPhysics-Informed Neural Networks NeuralPDE\nNeural Operators NeuralOperators\nHigh Dimensional Deep Learning HighDimPDE","category":"page"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"* Denotes a non-SciML package that is heavily tested against as part of SciML workflows and has frequent collaboration with the SciML developers.","category":"page"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"(Image: SciML Mind Map)","category":"page"},{"location":"overview/#Domains-of-SciML","page":"Detailed Overview of the SciML Software Ecosystem","title":"Domains of SciML","text":"","category":"section"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"The SciML common interface covers the following domains:","category":"page"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"Linear systems (LinearProblem)\nDirect methods for dense and sparse\nIterative solvers with preconditioning\nNonlinear Systems (NonlinearProblem)\nSystems of nonlinear equations\nScalar bracketing systems\nIntegrals (quadrature) (IntegralProblem)\nDifferential Equations\nDiscrete equations (function maps, discrete stochastic (Gillespie/Markov) simulations) (DiscreteProblem and JumpProblem)\nOrdinary differential equations (ODEs) (ODEProblem)\nSplit and Partitioned ODEs (Symplectic integrators, IMEX Methods) (SplitODEProblem)\nStochastic ordinary differential equations (SODEs or SDEs) (SDEProblem)\nStochastic differential-algebraic equations (SDAEs) (SDEProblem with mass matrices)\nRandom differential equations (RODEs or RDEs) (RODEProblem)\nDifferential algebraic equations (DAEs) (DAEProblem and ODEProblem with mass matrices)\nDelay differential equations (DDEs) (DDEProblem)\nNeutral, retarded, and algebraic delay differential equations (NDDEs, RDDEs, and DDAEs)\nStochastic delay differential equations (SDDEs) (SDDEProblem)\nExperimental support for stochastic neutral, retarded, and algebraic delay differential equations (SNDDEs, SRDDEs, and SDDAEs)\nMixed discrete and continuous equations (Hybrid Equations, Jump Diffusions) (DEProblems with callbacks and JumpProblem)\nOptimization (OptimizationProblem)\nNonlinear (constrained) optimization\n(Stochastic/Delay/Differential-Algebraic) Partial Differential Equations (PDESystem)\nFinite difference and finite volume methods\nInterfaces to finite element methods\nPhysics-Informed Neural Networks (PINNs)\nIntegro-Differential Equations\nFractional Differential Equations\nSpecialized Forms\nPartial Integro-Differential Equations (PIPDEProblem)\nData-driven modeling\nDiscrete-time data-driven dynamical systems (DiscreteDataDrivenProblem)\nContinuous-time data-driven dynamical systems (ContinuousDataDrivenProblem)\nSymbolic regression (DirectDataDrivenProblem)\nUncertainty quantification and expected values (ExpectationProblem)","category":"page"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"The SciML common interface also includes ModelingToolkit.jl for defining such systems symbolically, allowing for optimizations like automated generation of parallel code, symbolic simplification, and generation of sparsity patterns.","category":"page"},{"location":"overview/#Inverse-Problems,-Parameter-Estimation,-and-Structural-Identification","page":"Detailed Overview of the SciML Software Ecosystem","title":"Inverse Problems, Parameter Estimation, and Structural Identification","text":"","category":"section"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"Parameter estimation and inverse problems are solved directly on their constituent problem types using tools like SciMLSensitivity.jl. Thus for example, there is no ODEInverseProblem, and instead ODEProblem is used to find the parameters p that solve the inverse problem. Check out the SciMLSensitivity documentation for a discussion on connections to automatic differentiation, optimization, and adjoints.","category":"page"},{"location":"overview/#Common-Interface-High-Level-Overview","page":"Detailed Overview of the SciML Software Ecosystem","title":"Common Interface High Level Overview","text":"","category":"section"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"The SciML interface is common as the usage of arguments is standardized across all of the problem domains. Underlying high level ideas include:","category":"page"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"All domains use the same interface of defining a AbstractSciMLProblem which is then solved via solve(prob,alg;kwargs), where alg is a AbstractSciMLAlgorithm. The keyword argument namings are standardized across the organization.\nAbstractSciMLProblems are generally defined by a AbstractSciMLFunction which can define extra details about a model function, such as its analytical Jacobian, its sparsity patterns and so on.\nThere is an organization-wide method for defining linear and nonlinear solvers used within other solvers, giving maximum control of performance to the user.\nTypes used within the packages are defined by the input types. For example, packages attempt to internally use the type of the initial condition as the type for the state within differential equation solvers.\nsolve calls should be thread-safe and parallel-safe.\ninit(prob,alg;kwargs) returns an iterator which allows for directly iterating over the solution process\nHigh performance is key. Any performance that is not at the top level is considered a bug and should be reported as such.\nAll functions have an in-place and out-of-place form, where the in-place form is made to utilize mutation for high performance on large-scale problems and the out-of-place form is for compatibility with tooling like static arrays and some reverse-mode automatic differentiation systems.","category":"page"},{"location":"overview/#Flowchart-Example-for-PDE-Constrained-Optimal-Control","page":"Detailed Overview of the SciML Software Ecosystem","title":"Flowchart Example for PDE-Constrained Optimal Control","text":"","category":"section"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"The following example showcases how the pieces of the common interface connect to solve a problem that mixes inference, symbolics, and numerics.","category":"page"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"(Image: )","category":"page"},{"location":"overview/#External-Binding-Libraries","page":"Detailed Overview of the SciML Software Ecosystem","title":"External Binding Libraries","text":"","category":"section"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"diffeqr\nSolving differential equations in R using DifferentialEquations.jl with ModelingToolkit for JIT compilation and GPU-acceleration\ndiffeqpy\nSolving differential equations in Python using DifferentialEquations.jl","category":"page"},{"location":"overview/#Note-About-Third-Party-Libraries","page":"Detailed Overview of the SciML Software Ecosystem","title":"Note About Third Party Libraries","text":"","category":"section"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"The SciML documentation references and recommends many third party libraries for improving ones modeling, simulation, and analysis workflow in Julia. Take these as a positive affirmation of the quality of these libraries, as these libraries are commonly tested against by SciML developers and are in contact with the development teams of these groups. It also documents the libraries which are commonly chosen by SciML as dependencies. Do not take omissions as negative affirmations against a given library, i.e. a library left off of the list by SciML is not a negative endorsement. Rather, it means that compatibility with SciML is untested, SciML developers may have a personal preference for another choice, or SciML developers may be simply unaware of the library's existence. If one would like to add a third party library to the SciML documentation, open a pull request with the requested text.","category":"page"},{"location":"overview/","page":"Detailed Overview of the SciML Software Ecosystem","title":"Detailed Overview of the SciML Software Ecosystem","text":"Note that the libraries in this documentation are only those that are meant to be used in the SciML extended universe of modeling, simulation, and analysis and thus there are many high quality libraries in other domains (machine learning, data science, etc.) which are purposefully not included. For an overview of the Julia package ecosystem, see the JuliaHub Search Engine.","category":"page"},{"location":"highlevels/symbolic_tools/#Symbolic-Model-Tooling-and-JuliaSymbolics","page":"Symbolic Model Tooling and JuliaSymbolics","title":"Symbolic Model Tooling and JuliaSymbolics","text":"","category":"section"},{"location":"highlevels/symbolic_tools/","page":"Symbolic Model Tooling and JuliaSymbolics","title":"Symbolic Model Tooling and JuliaSymbolics","text":"JuliaSymbolics is a sister organization of SciML. It spawned out of the symbolic modeling tools being developed within SciML (ModelingToolkit.jl) to become its own organization dedicated to building a fully-featured Julia-based Computer Algebra System (CAS). As such, the two organizations are closely aligned in terms of its developer community and many of the SciML libraries use Symbolics.jl extensively.","category":"page"},{"location":"highlevels/symbolic_tools/#ModelOrderReduction.jl:-Automated-Model-Reduction-for-Fast-Approximations-of-Solutions","page":"Symbolic Model Tooling and JuliaSymbolics","title":"ModelOrderReduction.jl: Automated Model Reduction for Fast Approximations of Solutions","text":"","category":"section"},{"location":"highlevels/symbolic_tools/","page":"Symbolic Model Tooling and JuliaSymbolics","title":"Symbolic Model Tooling and JuliaSymbolics","text":"ModelOrderReduction.jl is a package for automating the reduction of models. These methods function a submodel with a projection where solving the smaller model gives approximation information about the full model. MOR.jl uses ModelingToolkit.jl as a system description and automatically transforms equations to the subform, defining the observables to automatically lazily reconstruct the full model on-demand in a fast and stable form.","category":"page"},{"location":"highlevels/symbolic_tools/#Symbolics.jl:-The-Computer-Algebra-System-(CAS)-of-the-Julia-Programming-Language","page":"Symbolic Model Tooling and JuliaSymbolics","title":"Symbolics.jl: The Computer Algebra System (CAS) of the Julia Programming Language","text":"","category":"section"},{"location":"highlevels/symbolic_tools/","page":"Symbolic Model Tooling and JuliaSymbolics","title":"Symbolic Model Tooling and JuliaSymbolics","text":"Symbolics.jl is the CAS of the Julia programming language. If something needs to be done symbolically, most likely Symbolics.jl is the answer.","category":"page"},{"location":"highlevels/symbolic_tools/#MetaTheory.jl:-E-Graphs-to-Automate-Symbolic-Transformations","page":"Symbolic Model Tooling and JuliaSymbolics","title":"MetaTheory.jl: E-Graphs to Automate Symbolic Transformations","text":"","category":"section"},{"location":"highlevels/symbolic_tools/","page":"Symbolic Model Tooling and JuliaSymbolics","title":"Symbolic Model Tooling and JuliaSymbolics","text":"Metatheory.jl is a library for defining e-graph rewriters for use on the common symbolic interface. This can be used to do all sorts of analysis and code transformations, such as improving code performance, numerical stability, and more. See Automated Code Optimization with E-Graphs for more details.","category":"page"},{"location":"highlevels/symbolic_tools/#SymbolicUtils.jl:-Define-Your-Own-Computer-Algebra-System","page":"Symbolic Model Tooling and JuliaSymbolics","title":"SymbolicUtils.jl: Define Your Own Computer Algebra System","text":"","category":"section"},{"location":"highlevels/symbolic_tools/","page":"Symbolic Model Tooling and JuliaSymbolics","title":"Symbolic Model Tooling and JuliaSymbolics","text":"SymbolicUtils.jl is the underlying utility library and rule-based rewriting language on which Symbolics.jl is developed. Symbolics.jl is standardized type and rule definitions built using SymbolicUtils.jl. However, if non-standard types are required, such as symbolic computing over Fock algebras, then SymbolicUtils.jl is the library from which the new symbolic types can be implemented.","category":"page"},{"location":"#SciML:-Differentiable-Modeling-and-Simulation-Combined-with-Machine-Learning","page":"SciML: Open Source Software for Scientific Machine Learning with Julia","title":"SciML: Differentiable Modeling and Simulation Combined with Machine Learning","text":"","category":"section"},{"location":"","page":"SciML: Open Source Software for Scientific Machine Learning with Julia","title":"SciML: Open Source Software for Scientific Machine Learning with Julia","text":"The SciML organization is a collection of tools for solving equations and modeling systems developed in the Julia programming language with bindings to other languages such as R and Python. The organization provides well-maintained tools which compose together as a coherent ecosystem. It has a coherent development principle, unified APIs over large collections of equation solvers, pervasive differentiability and sensitivity analysis, and features many of the highest performance and parallel implementations one can find.","category":"page"},{"location":"","page":"SciML: Open Source Software for Scientific Machine Learning with Julia","title":"SciML: Open Source Software for Scientific Machine Learning with Julia","text":"Scientific Machine Learning (SciML) = Scientific Computing + Machine Learning","category":"page"},{"location":"#Where-to-Start?","page":"SciML: Open Source Software for Scientific Machine Learning with Julia","title":"Where to Start?","text":"","category":"section"},{"location":"","page":"SciML: Open Source Software for Scientific Machine Learning with Julia","title":"SciML: Open Source Software for Scientific Machine Learning with Julia","text":"Want to get started running some code? Check out the Getting Started tutorials.\nWhat is SciML? Check out our Overview.\nWant to see some cool end-to-end examples? Check out the Extended Tutorials.\nCurious about our performance claims? Check out the SciML Open Benchmarks.\nWant to chat with someone? Check out our chat room and forums.\nWant to see our code? Check out the SciML Github organization.","category":"page"},{"location":"","page":"SciML: Open Source Software for Scientific Machine Learning with Julia","title":"SciML: Open Source Software for Scientific Machine Learning with Julia","text":"And for diving into the details, use the bar on the top to navigate to the submodule of interest!","category":"page"}]
}
